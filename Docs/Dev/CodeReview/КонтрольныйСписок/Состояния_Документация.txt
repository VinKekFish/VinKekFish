
Определить набор файлов для проверки и выписать их в файл "+.txt" в директории проверки
У каждого файла поставить знак "?", который заменить на "+" или "!", если файл проверен или если найдены ошибки. "x" - если проверка не была завершена, "-" - если проверка была обоснованно не произведена или остановлена.

В копии исходного кода писать "ФАЙЛ ДЛЯ АНАЛИЗА" и писать внутри в комментариях сам текст анализа. Если нужна ссылка на строку исходного кода, делать её по неизменяемой копии оригинала (в папке sources)
Можно анализировать из разных редакторов: исходники из VisualStudio, а проверку делать во внешнем редакторе. Пометки номеров строк делать по строкам неизменяемой копии в папке "sources"
Если есть желание, создать файл "+.txt" для записи результатов и найденных ошибок.


1. Проверка документации.
	0. Проверить, что состояния объектов где-то документированы и ссылка на документацию указана в исходниках как относительный путь к файлу (или, если это удобнее, как абсолютный путь от корня проекта).
	На каждый проверяемый файл можно создать свою копию контрольного файла для проверки либо указывать проверки прямо в файле.
	Если в директорию копируется неизменяемая копия оригинала, то к его имени добавляется ".original"
	1. Обратить особое внимание на то, что у объектов есть состояния "не инициализирован", "очищен"  и "уничтожен"
		1.1. Желательно, чтобы эти состояния были в одной группе
		1.2. 
			1.2.1. Из состояния "уничтожен" не должно быть выходов
			1.2.2. "Уничтожен" должно быть конечным состоянием (декларировано как конечное).
			1.2.3. В состояния "Очищен" и "Уничтожен" можно попасть напрямую или опосредованно из любого другого состояния без проведения каких-либо операций, не соответствующих семантике очистки/уничтожения (пока код не проверяется, только описание состояний)
			1.2.4. По возможности, во время исполнения должна быть проверка того, что объект действительно подвергся очистке или уничтожению (то есть, что он не забыт)
		1.3. -
		1.4. В состоянии "не инициализирован" должно соответствовать семантике и быть сразу же после вызова конструктора. Если нужна дополнительная инициализация, то состояний "не инициализирован" может быть несколько.
	2. Обратить особое внимание на то, указан ли допустимый порядок использования объекта (в зависимости от его состояний; допустимые переходы) и рекомендованный порядок состояний. Они должны быть указаны как в документации по состояниям, так и в понятной программисту-пользователю документации
	3. Переменные объекта.
		3.0. Можно ли во время выполнения отличить, в каком состоянии находится объект?  (какие переменные на это указывают?) Если нельзя, то почему?
		3.1. Если есть переменные, которые указывают на состояние объекта, но не соответствуют формально описанным состояниям, то, возможно, стоит ввести новые группы состояний? (например, разделить группы)
		3.2. Если объект инициализируется по частям и очищается также, то выделены ли эти инициализации в отдельные группы состояний (со своими "частично очищен") и т.п.?
	4. Проверить, понятно ли описано, как создавать, использовать, утилизировать (очищать) объект для конченого программиста-пользователя
	5. Все ли методы объекта указаны в документации по состояниям?
		5.0. Все ли методы перечисленны? Все перегрузки методов одинаково влияют на состояния (если они перечислены под одним именем)?
		5.1. Есть ли у каждого метода все группы состояний? Соответствуют ли они семантике метода?
		5.2. Хотя бы для одной группы должно быть верно следующее. Метод всегда некорректно вызывать в одних состояниях группы и всегда корректно вызывать в других состояниях группы (то есть нет состояния, где его вызов может оказаться как корректным, так и не корректным)
	6. Пригодные и непригодные состояния
		1. Можно ли (во время исполнения программы) понять, что объект находится в состоянии "Утилизирован" ("уничтожен")? Если нет, то объект должен быть, после утилизации, недоступен.
		2. Можно ли во время выполнения программы понять, что объект находится в других непригодных состояниях? ("не инициализирован", "очищен", "частично инициализирован" и т.п.)
		3. Можно ли во время исполнения программы понять, что объект находится в нужном для основного использования состоянии?
			1. Верно инициализирован
			2. Функции основного использования корректно вызывать в этом состоянии

