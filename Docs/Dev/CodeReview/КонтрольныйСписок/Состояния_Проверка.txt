Проверка начинается с анализа статических конструкторов программы. Анализируется только создание сложных объектов.
Затем проверка переходит к функциям программы (класса) в удобном для анализе порядке.

Если нужно, проверка осуществляется несколькими проходами.

1. Выписать все объекты, которые используются в ходе программы (в проверяемой части, в том числе, в статических методах) либо передаются из-вне.
	0. Все объекты проверяемого класса
	1. Все объекты, которые глобально (вне одной функции) используются проверяемым участком программы
	2. Все объекты, которые локально (внутри функции) используются в программе: пройти по всем функциям и заранее выписать эти объекты в отдельный список, идущий сразу после функции, чтобы потом не забыть
		Обратить внимание на то, что в функциях могут быть безымянные объекты, которые передаются как выход из одной функции на вход другой
2.
	1. Для всех выписанных объектов (вне одной функции) указать их начальные состояния, если их сразу можно выяснить (если нет, то это будет выясняться далее в WMv05ZkV8lkD).
	2. Для всех выписанных объектов указать, в каких состояниях они должны быть на входе и выходе из функции, если это требование (отметить, что это требование, а не результат проверки).


lfQFibWa0cRr. Составить граф вызовов функций (отдельный проход по всей программе)
	1. Пометить функции, достижимые из вызываемых пользователем функций, как используемые

LSpqK5mC. Завершающие состояния (проход по всей программе)
	0. Если для объекта нет отдельного списка состояний, использовать следующий
		MCaZG5ctJub4
			0. Не создан
			1. Не инициализирован
			2. Готов к использованию
			3. Не готов к использованию (если такое может быть; в том числе, уничтожен, но доступен)
			4. Очищен
			5. Уничтожен
			6. Ссылка на объект очищена
	Также можно использовать доп. списки
		KmMYNx4twrG9. Не создан - ссылка нулевая / Есть ссылка / Ссылка очищена
		hzc21pUOzxfb. Только для чтения / Допустимы все операции
		NSMdQiQ9Xfbb. Ссылка имеет копии / ссылка не имеет копий
		CYGFmLaJZccb. Копия ссылки должна быть очищена (освобождена) / Копия ссылки не должна быть очищена (освобождена)

	cFNNZfO63pYL. Для каждого объекта также необходимо указать
		1. он находится в каких-то списках (в каких именно? Когда произойдёт удаление из списка?)
		2. с него делается зависимая копия (которая не должна изменяться независимо от этого объекта - где эта копия и когда она будет удалена либо потеряет зависимость)
		3. делается копия ссылки (указателя, адреса) на этот объект (где, когда будет обнулена, какая из ссылок - копия, а какая - оригинал [память под оригинал нужно освободить, если это нужно делать вручную])
			В частности, нужно обратить внимание на то, что ссылка на объект могла быть запомнена в другом объекте, в том числе, в лексическом замыкании
		4. Может ли вышестоящие пункты выполнить программист-пользователь
		5. Если производится копия, полностью ли скопирован объект? Что скопировано, а что скопировано по ссылке? Есть ли то, что не скопировано?
		(добавить в код замечания для проверки, если что-то из этого есть)

WMv05ZkV8lkD. Состояния внутри функций, перед и после функций
	1. В каком состоянии объекты находятся в начале функции? Соответствует ли это документации?
	2. В каком состоянии объекты находятся в конце функции? Соответствует ли это документации?
	3. Состояния при использовании (на каждой строке функции)
		1. В каком состоянии объекты находятся перед использованием? В том числе, объект, содержащий эту функцию как метод
		2. Допустимо ли это использование в этом состоянии?
		3. В каком состоянии объекты находятся после использования? Соответствует ли это документации? (проходят ли по документации объекты соотв. промежуточные состояния?)
		4. Можно ли вызвать эту функцию из-вне (программистом-пользователем) так, что объекты будут находится в других состояниях, нежели описанные?
		5. Есть ли от этого некорректного вызова защита? Описано ли это в документации, если нужно?

		2azaN6FM6Tm2. Если объект подвергается каким-либо ещё внешним операциям, возможно, для него есть отдельная группа состояний. Указать её.
			1. Если объект подвергается фиксированию (если он может быть перемещён в оперативной памяти), то объект нужно проверить на снятие фиксирования.
			2. Если объект является отображением другого объекта, подумать над его состояниями (доступ к файлу) и, возможно, выписать его состояния, если они определены

	4. Для каждой функции в документации указать, если она производит операции с объектом из списка cFNNZfO63pYL (для того, чтобы при вызове этой функции можно было бы это учесть)
	5. Переводит ли функция (метод) в нужное состояние программу из любого другого доступного состояния?
	6. Возможно ли вызвать эту функцию повторно (сразу же)? Если нет, есть ли от этого защита?
	7. Если функция вызывается из двух разных потоков и это нельзя, возможно ли по состояниям понять это? Если невозможно, добавить состояния.
	8. Что будет с состояниями объектов, если в функции возникнут исключения?

	ZqYby51y. Все ли выписанные объекты:
		1. Созданы?
		2.
			Простые объекты: дошли до состояния "Готов к использованию" (если нет, то зачем этот объект нужен?)?
			Сложные объекты: все ли выписанные объекты прошли допустимый или рекомендуемый цикл состояний?
		3. Очищены (копии объектов проверяются отдельно)
		4. Уничтожены. В частности, освобождена память объекта:
			1. объект не находится ни в каких списках ни сам
			2. ни его лексические замыкания
			3. никто не подписан на его события
			4. он не подписан ни на чьи события
		5. Ссылки на объект очищены
		6. Проверить список cFNNZfO63pYL

ThMqBtLMkYWW. Уничтожение и очистка объекта
	Деструктор объекта:
		0. Деструктор переводит объект в состояние "очищен" или "уничтожен" (с вызовом исключения, если объект ещё не очищен вручную)?
		1. Верен ли вызов деструктора, если объект уже "очищен" или "уничтожен"?
		
	Функции очистки:
		0. Переводят ли объект в состояние "очищен" (очищают ли реально объект? Вся ли конфиденциальная информация перезаписана? Вся ли информация вообще перезаписана?). Что, если какие-то ссылки - null? Или объект в некорректном состоянии?
		1. Вызванная повторно, функция работает верно?
		2. Если в функции очистки возникнут исключения, верно ли она отработает?
