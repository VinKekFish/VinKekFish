# Общие типы сценариев

©:GS4V4dkV7MRd7QZuh118:auto
1. Должна быть возможность использования программы в автоматическом режиме, то есть без участия человека (из скрипта или другой программы)

©:GS4V4dkV7MRd7QZuh118:manual
2. Должна быть возможность использования программы в ручном режиме с подсказками пользователю


# Общие сценарии

Сбор энтропии в фоновом режиме (системная служба)
    {©:EYyjXrpAl2nUyJ0Jz1rd}
    Автоматическая запись на диск части псевдослучайной информации для дальнейшего её использования в качестве дополнительной рандомизации. Автоматическое взятие информации после старта программы из этого файла
        {©:P1BLfeLrFqASnQ2Q6iRc}
        Файл должен быть защищён правами доступа
        Подгрузка такого файла уже после старта фоновой программы, когда файл будет расшифрован вручную
            Его периодическое обновление либо обновление каким-либо другим образом (по команде пользователя; при закрытии программы, если файл всё ещё на месте)
        Файл не должен записываться, если введено слишком мало данных: теоретически, из этого файла можно понять, что именно вводилось
    Сбор энтропии в фоновом режиме с мышки и клавиатуры (/dev/input/), /proc/meminfo, ps, двух потоков с инкрементом, /dev/random, ping (запущенный с низким приоритетом), dstat или чего-то подобного (возможно, нужно подумать насчёт непосредственного сбора информации из /proc без ps и из man iostat: /proc/diskstats, /proc/stat, /proc/uptime, /dev/disk)
        while true; do cat /proc/stat | egrep -o 'intr.{15}'; sleep 1;  done;
            Судя по всему, один бит в секунду точно даёт (разница между разными вызовами, например, 865,562,842,577)
        Вероятнее всего, сбор будем делать со следующих источников:
            /dev/input/* (mouse0 даёт где-то 512-ть байтов от перемещения горизонтально через весь экран)
            /proc/meminfo
            двух потоков с инкрементом
            /dev/random разово при старте, через какое-то время после старта и через какой-то период времени регулярно, либо getrandom из libc (доп. проверять /proc/sys/kernel/random/entropy_avail) man 4 random man 7 random man 2 getrandom
            попытка получить данные из /dev/hwrng ("нет такого устройства")
            /proc/diskstats
            /proc/stat
            /proc/zoneinfo
            df -aT (или df -T) разово при старте и через удлинённый промежуток времени
            /proc/version; /proc/ioports; /proc/cpuinfo разово при старте
            /sys/class/net/*/statistics/tx_packets; tx_bytes либо вообще cat * по всей директории (там нули обычно)  cat /sys/class/net/*/statistics/tx_packets и то же для rx*;  rx_* - количество полученных, tx - количество переданных
            ping (если пользователь введёт): через определённый пользователем промежуток времени
            ps с какими-то флагами (редко)
            иные пользовательские команды




Генерация ключей спец. формата VinKekFish
    {©:SV6l588WHXnroA8qLUSr}
    Генерация ключей, которые для использования требуют знания другого ключа, а не пароля
        Такие ключи, сами по себе, не хранят информацию о главном ключе (нужно указать ключ)
        Такие ключи, наоборот, хранят информацию о главном ключе
Проверка правильности паролей на ключ и самого ключа на целостность (для вспоминания пароля)
    {©:kRnK1bXgaLNZSB76rN2f}
Генерация паролей и псевдослучайных последовательностей и файлов, в том числе, ключевых файлов
    {©:xCGJFfzUWwFfn5FLfyUB}
    Использование нескольких разных файлов для того, чтобы сгенерировать один ключевой файл


Хеширование файлов, в том числе, аутентифицированное ключом или с открытым вектором инициализации
    {©:eo0aMwycKVXlrjmjJuKI}
Проверка строк хешей на совпадение (без хеширования, только строки)
    {©:6VSFm3uo8Wsaq39q83P2}
Шифрование файлов
    {©:DT1G2k5j04YiFqcmNCnP}
    Шифрование файлов несколькими ключами разными алгоритмами (с запоминанием в спец. ключевом файла порядка шифрования)
    Шифрование файлов несколькими ключами с каскадированием алгоритмов и автоматическим запоминанием, какие именно ключи были использованы (запоминание должно происходить в ключах, которые сразу при генерировании должны предполагать такое каскадирование; в файлах хранить информацию нельзя)
    Шифрование файлов с минимумом доп. информации и без выравнивания (для стеганографирования)
        {©:SQTPBZTHrU4Zuk5Gcvz6}
    ? Шифрование папок с автоматическим вызовом функций архивации, если доступны в ОС
        Сделать проверку при запуске программы без параметров на наличие 7z, git и прочее
    ? Расшифрование с автоматическим разархивированием (в tmpfs-директорию?)
    ?? Шифрование папок с автоматическим коммитом .git, архивацией и отслеживанием изменений в папках
        Причём без необходимости архивировать и перешифровывать все файлы
    ??? Было бы неплохо сделать шифрование логических дисков, как в VeraCrypt, через fuse
    Шифрование файлов с ключом без пароля и с ключом с паролем

??? Хранение ключевой информации в памяти для временного кеширования, чтобы не вводить пароли заново
    {©:UmBt6WeQPOMGX9OeyL5d}
    Возможно, стоит сделать внутри сервиса и передавать через pipe или unix stream (сохранение под уникальным именем и возможность получения только под ним же). [вообще, это больше похоже на уязвимость]


