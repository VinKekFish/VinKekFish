# Общие типы сценариев

©:GS4V4dkV7MRd7QZuh118:auto
1. Должна быть возможность использования программы в автоматическом режиме, то есть без участия человека (из скрипта или другой программы)

©:GS4V4dkV7MRd7QZuh118:manual
2. Должна быть возможность использования программы в ручном режиме с подсказками пользователю


# Общие сценарии

Сбор энтропии в фоновом режиме (системная служба)
    {©:EYyjXrpAl2nUyJ0Jz1rd}
    Автоматическая запись на диск части псевдослучайной информации для дальнейшего её использования в качестве дополнительной рандомизации. Автоматическое взятие информации после старта программы из этого файла
        {©:P1BLfeLrFqASnQ2Q6iRc}
        Файл должен быть защищён правами доступа
        Подгрузка такого файла уже после старта фоновой программы, когда файл будет расшифрован вручную
            Его периодическое обновление либо обновление каким-либо другим образом (по команде пользователя; при закрытии программы, если файл всё ещё на месте)
        Файл не должен записываться, если введено слишком мало данных: теоретически, из этого файла можно понять, что именно вводилось
    Сбор энтропии в фоновом режиме с мышки и клавиатуры (/dev/input/), /proc/meminfo, ps, двух потоков с инкрементом, /dev/random, ping (запущенный с низким приоритетом), dstat или чего-то подобного (возможно, нужно подумать насчёт непосредственного сбора информации из /proc без ps и из man iostat: /proc/diskstats, /proc/stat, /proc/uptime, /dev/disk); lslocks
        while true; do cat /proc/stat | egrep -o 'intr.{15}'; sleep 1;  done;
            Судя по всему, один бит в секунду точно даёт (разница между разными вызовами, например, 865,562,842,577)
        Вероятнее всего, сбор будем делать со следующих источников:
            /dev/input/* (mouse0 даёт где-то 512-ть байтов от перемещения горизонтально через весь экран на 1280x1024)
            /proc/meminfo
            двух потоков с инкрементом
            /dev/random разово при старте, через какое-то время после старта и через какой-то период времени регулярно, либо getrandom из libc (доп. проверять /proc/sys/kernel/random/entropy_avail) man 4 random man 7 random man 2 getrandom
            попытка получить данные из /dev/hwrng ("нет такого устройства")
            /proc/diskstats
            /proc/stat
            /proc/zoneinfo
            df -aT (или df -T) разово при старте и через удлинённый промежуток времени
            /proc/version; /proc/ioports; /proc/cpuinfo; ll -R /dev - всё разово при старте
            /sys/class/net/*/statistics/tx_packets; tx_bytes либо вообще cat * по всей директории (там нули обычно)  cat /sys/class/net/*/statistics/tx_packets и то же для rx*;  rx_* - количество полученных, tx - количество переданных
            dmesg
            При старте: lsblk; lscpu; lshw; lslogins; lsmem; lsmod; lspci; lsusb
            cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq
            ping (если пользователь введёт): через определённый пользователем промежуток времени
            ps -eo pid,times,rss,nlwp,args --sort time,rss,pid,args (редко)
            температура процессора (например, sensors из lm-sensors)
            иные пользовательские команды

    Проверка вручную (пользователем) информации, которую собирает VinKekFish в качестве энтропии (для отладки и того, чтобы убедиться, что информация действительно энтропийна)



Генерация ключей спец. формата VinKekFish
    {©:SV6l588WHXnroA8qLUSr}
    Генерация ключей, которые для использования требуют знания другого ключа, а не пароля
        Такие ключи, сами по себе, не хранят информацию о главном ключе (нужно указать ключ)
        Такие ключи, наоборот, хранят информацию о главном ключе
Проверка правильности паролей на ключ и самого ключа на целостность (для вспоминания пароля)
    {©:kRnK1bXgaLNZSB76rN2f}
Генерация паролей и псевдослучайных последовательностей и файлов, в том числе, ключевых файлов
    {©:xCGJFfzUWwFfn5FLfyUB}
    Использование нескольких разных файлов для того, чтобы сгенерировать один ключевой файл


Хеширование файлов, в том числе, аутентифицированное ключом или с открытым вектором инициализации
    {©:eo0aMwycKVXlrjmjJuKI}
Проверка строк хешей на совпадение (без хеширования, только строки)
    {©:6VSFm3uo8Wsaq39q83P2}
Шифрование файлов
    {©:DT1G2k5j04YiFqcmNCnP}
    Шифрование файлов несколькими ключами разными алгоритмами (с запоминанием в спец. ключевом файла порядка шифрования)
    Шифрование файлов несколькими ключами с каскадированием алгоритмов и автоматическим запоминанием, какие именно ключи были использованы (запоминание должно происходить в ключах, которые сразу при генерировании должны предполагать такое каскадирование; в файлах хранить информацию нельзя)
    Шифрование файлов с минимумом доп. информации и без выравнивания (для стеганографирования)
        {©:SQTPBZTHrU4Zuk5Gcvz6}
    Шифрование файлов с большими шумами и полной взаимосвязанностью для того, чтобы их было легче удалять в шифрованном виде
        Объём файла не менее 2^19 байтов (512 кбайтов) для того, чтобы увеличить вероятность перезатирания хотя бы одного фрагмента файла на твердотельном носителе
    Отрицаемое шифрование для всего, кроме стеганографии
        То есть запись в один файл нескольких файлов или запись пустого шума вместо файла, если он не задан
        Должно ли быть записано в ключе, какой именно поток данных является информативным? (не выдаст ли это дополнительную информацию для кого-либо? Не войдут ли ключи в противоречие?)
    ? Шифрование папок с автоматическим вызовом функций архивации, если доступны в ОС
        Сделать проверку при запуске программы без параметров на наличие 7z, git и прочее
        Добавление файлов в уже готовый архив (но не изменение, если архив это не позволяет)
        Прицепление к новому архиву более старого, чтобы одной командой разархивировать сразу всю цепочку
    ? Расшифрование с автоматическим разархивированием (в tmpfs-директорию?)
    ?? Шифрование папок с автоматическим коммитом .git, архивацией и отслеживанием изменений в папках
        Причём без необходимости архивировать и перешифровывать все файлы
    ??? Было бы неплохо сделать шифрование логических дисков, как в VeraCrypt, через fuse
    Шифрование файлов с ключом без пароля и с ключом с паролем
    Добавление версий файлов к шифрованному файлу или автоматическое добавление даты и времени шифрования к имени файла
    Добавление к файлу, в начало, шифрованного имени вторичного ключа шифрования (режима шифрования). Как это сделать так, чтобы не препятствовать сокрытию ключа?


??? Хранение ключевой информации в памяти для временного кеширования, чтобы не вводить пароли заново
    {©:UmBt6WeQPOMGX9OeyL5d}
    Возможно, стоит сделать внутри сервиса и передавать через pipe или unix stream (сохранение под уникальным именем и возможность получения только под ним же). [вообще, это больше похоже на уязвимость]
    Хранение возможно сделать с помощью хранения производного ключа, по которому нельзя вычислить основной ключ. То есть при расшифровке основного ключа вводятся задачи, для которых будут генерироваться производные ключи. Затем, именно производные ключи временно запоминаются и позволяют без ввода пароля что-либо шифровать.
    Хранение может подразумевать ввод какого-то другого (более короткого) пароля, как одного на группу ключей, так и одного на каждый ключ.

Хранение ключевой информации и шифрование для разных ключей одного и того же
    Хранение ключей, зашифрованных мастер-ключом
    Каталог ключей
        Сокрытие количества ключей (как???) и факта нахождения какого-либо ключа
        Уничтожение ключей
        Экспорт/импорт ключей
        Подбор ключа, если неизвестно, каким ключом зашифрован файл (перебор позволяет противнику по энергопотреблению найти нужный ключ)
    Расшифрование ключа для шифрования только в том случае, если введён доп. пароль и/или есть ключевой файл
    Одновременное шифрование разными ключами (для разных людей) одного и того же файла (или ключа)
        или одновременное шифрование одним ключом, но с разными синхропосылками (для того, чтобы нельзя было сказать, что это - идентичные копии файлов)
        шифрование разными ключами и запись в один файл, чтобы было непонятно, сколько именно ключей было использовано
    Предусмотреть ввод другого пароля/файла в любой комбинации, который будет шифровать сообщение тревожным ключом
        Наличие тревожного ключа
        Невозможность различить, есть тревога или нет, если не знаешь штатного пароля
            как насчёт расшифровки уже зашифрованных файлов в качестве проверки?
    В ключе должно задаваться правило выравнивания файла, чтобы пользователь мог настроить это выравнивание под свои размеры файлов
        В том числе, шифрование даже пустого (вообще, не заданного файла) должно идти с выравниванием, чтобы можно было бы послать мусор


Ввод паролей
    Первичный ввод таблицей
    Вторичный ввод с клавиатуры?? (с терминала pts?)
    Третичный ввод со словаря, сохранённого непосредственно в файле


# Безопасность

Запуск программы через sudo из-под ограниченного пользователя (под ограниченным пользователем с правилом INTERCEPT)

Запуск программы в chroot
Запуск программы в apparmor


