# Работа с каскадами

В этом файле расположены описания дублирующих алгоритмов повышенной стойкости. Они также не проходили проверку криптоаналитиками.

Обозначение log подразумевает log2 (логарифм по основанию два)


# Каскад keccak
6. Полностью независимое шифрование каскадом keccak


## 6.1. Одинарный каскад keccak
Выполняется инициализация нескольких губок keccak ключами и синхропосылками (как минимум, верхняя губка). При этом губки строятся каскадами.
keccak0
keccak1
keccak2
...

Верхняя губка подаёт (в режиме duplex) свой выход на нижнюю (в качестве входа), нижняя подаёт свой выход на ещё более нижнюю, и так далее.
Каждый шаг губка впитывает вывод от более верхней губки и выдаёт вывод на более нижнюю губку.
Вывод самой нижней губки подаётся на вход верхней губки, обеспечивая обратную связь в каскаде.
Выход самой нижней губки является и выходом всего алгоритма в целом.

Шагом каскада является выполнение шагов губки для всех губок алгоритма (с распространением информации по каскаду).

При этом, данные, которые подаются в обратную связь должны быть любым способом изменены для того, чтобы обеспечить самостоятельный уход каскада от возможного состояния каскада, где состояния всех губок будут равны.
Для этого первое 8-мибайтовое слово губки может быть приращено на 1. Информация, попадающая на выход, не требует такого приращения. Приращение осуществляется только в обратной связи для того, чтобы обеспечить отличие обратной связи от прямой передачи информации вниз по губке.
Вместо приращения на 1 информация может быть подвергнута шифрованию TreeFish (с приращением его tweak на единицу каждый раз или без такового; ключ - любой, хоть ноль). При этом недостающая часть блока равна нулю в первый раз и равна предыдущему выходному блоку в следующий раз.
#### Таким образом, вычисление обратной связи с блоком TreeFish следующее.
1. Инициализировать доп. ключом TreeFish. Tweak инициализировать нулём или другим значением. (см. также "Генерация ключа для ThreeFish в обратной связи")
2. Открытый текст - инициализировать нулём
3. Ввести в левую половину блока TreeFish (блока открытого текста) выход с самой нижней губки keccak
4. Зашифровать блок открытого текста TreeFish и подать его на вход каскада. Выполнить шаг каскада
5. Открытый текст - сдвинуть левую половина блока в правую половину. Левую половину инициализировать выходом с самой нижней губки keccak. Tweak[0] прирастить на единицу (не обязательно; можно работать с tweak как угодно).
6. Перейти к пункту 4 (каждый шаг каскада выполяется одно шифрование TreeFish).

Дополнительные требования
1) В каскаде строго не менее 3-х губок для любой схемы шифрования.


#### Инициализация с вводом ключа и синхропосылки опосредованно (в самую верхнюю губку):
1. W=k
2. Ввести в самую верхнюю губку часть синхропосылки (512-ть битов или менее)
3. Провести 2\*k\*log(k)+k шагов каскада (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки, с учётом возможной потери информации при взаимодействии данных).
4. На следующих шагах вводить в губку данные через xor с обратной связью.
1) Взять выход "Out" самой нижней губки (512-ть битов). Выход берётся также, как для обычной обратной связи (с приращением на единицу).
2) Применить для нового блока данных (синхропосылки или ключа) xor с обратной связью. Таким образом мы вычислили изменённую обратную связь
3) Подать значение изменённой обратной связи в верхнюю губку (не проводя шагов губки).
4) Провести 2\*k\*log(k)+k шагов каскада. Перейти в шагу 4.1 или, если данные для инициализации закончились, перейти к шагу 5.
5. Ввести в режиме OVERWRITE обратную связь в верхнюю губку. Провести ещё 2\*k\*log(k)+k шагов каскада с обратной связью через xor. Считать губку проинициализированной

#### Инициализация с вводом ключа непосредственно в губки:
1. W=k
2. Ввести синхропосылку опосредованно (см. выше) либо разделить её на 512-тибитные блоки (или меньшие равные части) и ввести в каждую губку по отдельности.
4. Разделить ключ на 512-ти битные блоки.
5. Ввести в каждую губку свой блок так, как будто происходит отдельная инициализация только этой губки. Если ключевой информации не хватает, выполнять инициализацию в каскаде снизу вверх, пока хватает ключевых блоков (если последний блок не кратен 512-ти, всё равно его можно ввести). Если блоков слишком много, повторить инициализацию губок далее (после шага каждой губки ввести новые блоки) либо остаток ввести опосредованым способом. При этом, в любом случае, инициализация выполняется так, как будто каждая губка инициализируется отдельно. То есть пока никакого каскада не существует.
4. После инициализации губок провести 2\*k\*log(k)+k шагов каскада.


#### В режиме генерации ключа (или в режиме шифрования небольшого количества важных данных), выход берётся следующим образом:
1. W=k.
2. Провести после предыдущего взятия выхода (или инициализации) 2\*k\*log(k)+k шагов каскада вхолостую (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки, с учётом возможной потери информации при взаимодействии данных).
3. Сделать ещё один шаг каскада и взять ⌊64/W⌋ байтов из выхода. Перейти к пункту 2.




#### В режиме обычного шифрования выход берётся следующим образом:
1. W=1+log(k)
2. Взять ⌊64/W⌋ байтов из выхода (на каждом шаге губки)


#### В режиме гаммирования с обратной связью по открытому тексту использовать следующий режим:
1. W=2, либо W=1+log(k) для повышения стойкости. Для режима генерации ключа с вводом рандомизирующей информации W=k. Провести инициализацию губки, как описано выше
2. Провести k шагов каскада вхолостую (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки). Для режима генерации ключа - 2\*k\*log(k)+k шагов. (все шаги проводятся с обратной связью)
3. Взять ⌊64/W⌋ байтов из самой нижней губки на выход каскада
4. Сделать 1 шаг каскада вхолостую. Для режима генерации ключа - 2\*k\*log(k)+k шагов.
5. Взять обычный выход обратной связи Out. Пропустить Out через xor с открытым текстом (или с рандомизирующей информацией). Дать полученные данные на вход самой верхней губки (вместо обычной обратной связи).



#### Генерация ключа для ThreeFish в обратной связи
1. W=k либо W=2 (для меньшей стокойсти)
2. Провести инициализацию губки любым методом с обратной связью в виде операции +1 к младшему 8-мибайтовому слову (или другой изменяющей обратную связь операции; в том числе, годится ThreeFish с любым, даже нестойким, ключом)
3. Взять ⌊64/W⌋ байтов выхода для ключа ThreeFish.
4. Провести 2\*k\*log(k)+k шагов каскада в холостую (с обратной связью)
5. Если ключ ThreeFish всё ещё не вычислен, перейти к пункту 3
6. Теперь ввести в действие обратную связь с вычисленным ключом ThreeFish.
7. Выполнить 2\*k\*log(k)+k шагов каскада
8. Если ключ был вычислен в первый раз, то перейти к пункту 3 и заново вычислить ключ ThreeFish, используя уже вычисленный ключ ThreeFish в качестве ключа для ThreeFish-преобразователя обратной связи
9. Если ключ был вычислен во второй раз, ввести новый ключ ThreeFish и провести 2\*k\*log(k)+k шагов каскада для повторной инициализации (без какого-либо сброса состояний).


## 6.2. Двойной каскад keccak-Treefish
Создаётся два каскада, аналогичных описанным в пункте 6.1. k - количество уровней каскада.
keccak0L	keccak0R
keccak1L	keccak1R
keccak2L	keccak2R
keccak3L	keccak3R
...

Основной ключ данного каскада состоит из 2\*k\*512 битов (или удвоенного значения).
Дополнительный ключ данного каскада состоит ещё из (k+1)\*1024 битов.

Ключ/синхропосылка может быть подан в каждую губку отдельно либо опосредовано через самую верхнюю губку (аналогично одиночному каскаду). Синхропосылка - через tweak каждого TreeFish (или также опосредовано). Также синхропосылка может инициализировать отдельно каждую губку. После этого (без каскадирования) в эти губки вносятся части ключей шифрования (как будто губки одиночные).
Далее, на каждом шаге две верхние губки дают данные для одного блока TreeFish. TreeFish выполняет шифрование этих блоков и даёт на выход блок из 1024-х битов. Этот блок разделяется на две нижних губки (на их входы).
В качестве ключевой информации TreeFish принимает ключ 1024 бита. При этом кроме стандартного ключа в 1024 бита в tweak может быть записана либо ключевая информация, либо синхропосылка.

Обратная связь.
С обоих самых нижних губок информация поступает в Treefish аналогично более верхним слоям и, затем, переходит на самые верхние губки (обратная связь).
В случае необходимости ввода информации в каскадную губку, половина ввода вводится через xor с блоком, полученным от обратной связи, в левую (самую верхнюю) губку, а половина - в правую губку (либо ввод осуществляется только в левую губку).
В ThreeFish обратной связи tweak нужно приращать каждый шаг касакада. Причём tweak у других частей каскада приращаться не должен или должен приращаться по другому алгоритму (чтобы обеспечить выход из режима, где все губки каскада случайно имеют одни и те же состояния)

Выход.
С самых нижних губок информация поступает на выход. Для этого две губки дают 1024-ре бита информации для шифрования ещё одним ключом ThreeFish (без преобразования для обратной связи). Tweak и key[16] берётся отдельно из блока обратной связи.
После этого выходной блок ThreeFish используется для получения выхода.


В случае, если ключевой информации не хватает для ключей Threefish, они могут быть проинициализированны такой же двойной каскадной губкой, однако ключевые блоки в такой губке могут быть взяты с помощью дополнительного шага этого же уровня каскада.

Алгоритм такой инициализации
1. W=k
2. Ввести ключи и синхропосылки напрямую, так, как будто каскада нет (разбив ключ и синхропосылку на части либо только ключ на части, а синхропосылку использовать одну и ту же).
3. В каждом уровне каскада сформировать свой выход (с помощью шага губок). Этот выход является ключом ThreeFish
4. Провести не менее чем 2\*k\*log(k)+k шагов каскада
5. i = 0
6. Взять выход левой губки на уровне i и поместить его в левую часть ключа ThreeFish (перезаписав уже существующую часть ключа), работающего после уровня i
7. Провести не менее чем 2\*k\*log(k)+k шагов каскада. Выполнить i++ (приращение i на единицу). Повторить пункт 6.
8. После прохождения всех левых губок перейти на шаг 5 и повторить шаги уже для правых губок и правых частей ключей ThreeFish. После инициализации правых частей ключей ThreeFish (с выполнением 2\*k\*log(k)+k шагов каскада после последней перезаписи части ключа) алгоритм проинициализирован полностью без дополнительных шагов.
9. Для увеличения стойкости, можно пройти алгоритм повторно, начиная с пункта 4


Для ключа длиной L битов целесообразно использовать k=⌈L/2048⌉.
