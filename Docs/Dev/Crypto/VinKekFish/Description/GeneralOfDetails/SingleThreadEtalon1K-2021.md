Реализация VinKekFish K = 1 (описание в VinKekFish.md ) . Подробное описание на естественном языке

Однопоточный эталон для K = 1

Реализация в
VinKekFish\cryptoprime\VinKekFish\VinKekFishBase.cs

# Общие слова

## Декларируемые криптографические свойства

Алгоритм имеет параметр K = 1, то есть 25600 битов (3200 байтов) внутреннего состояния.

Заявленная стойкость: 4096 битов.

Номинальная стойкость: 4096 битов

Стойкость без запасов: 8-10 кбитов.

Размер ключа: ввозможны любые длины ключей
    Номинальное: 4096 битов
    Минимальное рекомендуемое: 8192 (1024 байта) (нормальная длина ключа)
    Эффективное рекомендуемое: 10 752 бита (1 344 байта)
    Рекомендуемое с запасом энтропии в ключе: 16384 бита (2048 байтов)

	REDUCED_KEY     = 512  (1024 бита) Уменьшенный ключ, соответствующий номинальной стойкости
	NORMAL_KEY      = 1024 (8192 бита) Нормальный ключ, соответствующей расчётной стойкости или запасу
	RECOMMENDED_KEY = 2048 (16384)	   Ключ с запасом по энтропии (если ключ будет недостаточно случайным, дополнительные биты ключа привнесут больше энтропии)


Размер ОВИ: не более 9184 битов (1148 байтов) MAX_OIV = 1148

Дополнительный ключ: Не более 1600 битов (рекомендуется 512-1024 бита). Не должен быть зависим от основного ключа. Доп. ключ может вводится как дополнение к основному в VinKekFish (конкатенацией, доп. ключ позади основного). Пользователь должен обеспечить, чтобы при разглашении дополнительного ключа основной оставался бы неизвестным (то есть по доп. ключу должно быть невозможно вычислить основной, т.к. доп. ключ используется в менее стойком шифровании и может быть проще раскрыт).


Длина выводимого/вводимого за один шаг блока: 4096 битов, 512 байтов. (BLOCK_SIZE=512)

Длина гаммы: при заявленной стойкости номинальная длина гаммы 2^4096 блоков, то есть 2^4105 байтов.


Количество раундов: не менее 1 (4 заключительных рандомизирующих keccak-f в количестве раундов не учитывается).
MIN_ABSORPTION_ROUNDS 	1	Минимальное количество раундов на поглощение (без вывода информации)
MIN_ROUNDS       		4 	Минимальное количество раундов
REDUCED_ROUNDS   		16	Рекомендуемое сниженное количество раундов
NORMAL_ROUNDS    		64	Рекомендуемое количество раундов
EXTRA_ROUNDS			256	Усиленное количество раундов

Максимальное количество шифруемой информации на одном ключе (нагрузка на ключ):
2^(17*(R-1)) байтов, но не более нормативной длины гаммы (2^6656 блоков), где R - количество раундов алгоритма. При R = 4 можно зашифровать 2^51 байтов (примерно, 2 Петабайта). См. "Нагрузка на ключ" в [VinKekFish.md](VinKekFish.md).


## Вводимая информация

### Первичная инициализация состояния
Первичная инициализация криптографического состояния производится по пункту "Инициализация нулями", то есть простой перезаписью всего состояния нулями.

### Открытые векторы инициализации
1. Основной ОВИ: вводится в VinKekFish во внутреннее состояние
	Размер ограничен 9184 битами (1148 байтов; MAX_OIV).
	
2. Побочный ОВИ: вводится в Tweak алгоритма.
	Размер не более 16-ти байтов. Допускается не вводить.
	Допускается вводить в tweak алгоритма keccak-хеш от основного ОВИ или фрагмент основного ОВИ.

### Ключ
Размер ключа не ограничен. Рекомендуется к вводу не менее 8192 бита ключевой информации.
Вводится в VinKekFish во внутреннее состояние с помощью простой перезаписи внутреннего состояния, ключ при вводе конкатенируется с его размером (см. func VinKekFish.ВводКлюча).
Таким образом возможно ввести до 16384 битов (2048 байтов) ключевой информации. Это константа MAX_SINGLE_KEY = 2048.

Возможен ввод удлинённого ключа. В таком случае, ввод производится с помощью xor поблочно. Константа MAX_MULTIPLE_KEY = 512 = BLOCK_SIZE определяет максимально возможное количество байтов, вводимых за один раунд.

При разработке шифра считается, что xor более шумящий по ПЭМИН, чем простая перезапись, поэтому первый ввод ключа осуществляется именно перезаписью. При этом, считается, что большое количество байтов при первом вводе и их совмещение с ОВИ (открытым вектором инициализации) будет осложнять многократное считывание одних и тех же сигналов и давать каждый раз другой радиорисунок.
Последующие же разы ввод осуществляется стандартно поблочно, но, возможно, с меньшим количеством раундов шифрования. Меньшее количество раундов шифрования позволяет ввести очень большой ключ (низкоэнтропийный, например).


### Дополнительный ключ
Дополнительный ключ используется для инициализации таблиц перестановок и вводится перед вводом основного ключа.
При вводе дополнительного ключа используется дуплекс keccak.
Ключ вводится в дуплекс keccak в режиме перезаписи внутреннего состояния keccak.

После этого, дуплекс keccak используется для генерации таблиц перестановок.
Вывод от генерирующего keccak duplex также может быть использован для дополнительной инициализации дублирующего keccak duplex.


# Описание

# Подготовительные стадии

## Ключ и ОВИ

### Словесное описание ввода ключа и ОВИ
1. Ввести в первый два байта криптографического состояния младший и старший байты длины ключа в байтах.

2. Ввести ключ с помощью перезаписи внутреннего состояния, но не более 2048-ми байтов (MAX_SINGLE_KEY)

3. Сразу после 2+2048 байтов ввести младший и старший байты длины ОВИ (не более 1148 байтов; MAX_OIV)

4. Ввести ОВИ с помощью перезаписи, но не более 1148 байтов (MAX_OIV)

4.1. Прирастить младшее слово tweak на 1253539379. Прирастить старшее слово tweak на общую длину ключа (длину ключа, вводимую за все шаги). Больше tweak никак не изменяется (количество вводимых байтов и режим не вводятся).

5. Сделать шаг шифрования (количество раундов может быть сокращено)

6. Если всё ещё остался ключ для ввода, ввести его с помощью xor аналогично пунктам 1 и 2. После каждого ввода делать шаг шифрования. Однако, константа MAX_SINGLE_KEY на последующих блоках заменяется на MAX_MULTIPLE_KEY.
Это связано с тем, что key, вводимый с помощью xor является более шумящей по ПЭМИН операцией. Поэтому, лучше вводить этот ключ более медленно (если кто-то смог полностью расшифровать xor, то он получит только данные из блока ввода). В целом, это не существенно (в реализации возможна замена MAX_MULTIPLE_KEY = MAX_SINGLE_KEY).
При вводе дополнительных порций ключа шифрование может быть с минимальным количеством раундов (MIN_ROUNDS).
tweak приращается на 1253539379 на каждый шаг шифрования, при это больше ввода туда нет (количество вводимых байтов и режим не вводятся). Режим вводится только при отбое

7. После полного окончания ввода делается ввод нулевого количества информации в режиме OVERWRITE. Это означает, что BLOCK_SIZE байтов будут перезаписаны нулями. После этого исполняется шаг алгоритма. Это делается для внесения необратимости (перезапись нулями - точно необратимая операция), чтобы усложнить получение ключа, даже если данные будут расшифрованы.
Количество раундов здесь должно быть, по возможности, как можно больше (рекомендуется NORMAL_ROUNDS).
Ввод нулей происходит стандартно со стандартным изменением tweak, то есть это уже полностью стандартная процедура ввода данных в режиме OVERWRITE.
Счётчик режимов при вводе отбоя устанавливается на 255.


# Алгоритмическое описание

	func VinKekFish.ВводКлюча
	ввод
		key:[512, *] массив байтов произвольной длины
			Ключ
		key.length: int
			Длина массива key (в байтах)
		StartIndexOfKey: int
			Начальный индекс, с которого начинается вводимая сейчас часть ключа
		OIV:[0, 1148] массив байтов произвольной длины
			Открытый вектор инициализации
		S:3200, массив байтов длины 3200
			Внутреннее состояние алгоритма. Должно быть проинициализированно начальными значениями
	
		Initiated:bool
			Если true, то состояние уже проинициализированно нестандартными значениями. Если false - то блок пустой (стандартно проинициализированный).
			
			Если false, то key записывается без xor, перезаписью.
			Обязательно использовать false тогда, когда записывается первый блок key
			Если записываются последующие блоки - рекомендуется использовать true.

		SecondKey: bool
			true - если первый ввод ключевой информации
			false - если повторный ввод
			В алгоритме предполагается, что Initiated == SecondKey

		tweak: массив из двух 8-мибайтовых целых чисел
			Используется в ThreeFish в преобразовании VinKekFish
		R: int
			Количество раундов для шифрования первого блока ключа (MAX_SINGLE_KEY байтов)
			Рекомендуется не менее 16-ти.
		RE: int
			Количество раундов для шифрования при отбое (перезаписи нулями)
			Не может быть равно нулю при пользовательском вызове (иначе не произойдёт отбоя)
			Равно нулю при рекурсивном вызове
		RM: int
			Количество раундов шифрования при вводе дополнительных частей ключа (более MAX_SINGLE_KEY байтов)

		State: структура для вывода информации о прогрессе алгоритма

	старт
		if OVI != null and OIV.length > MAX_OIV
			ОШИБКА! Вектор инициализации не может быть более MAX_OIV байтов

		if SecondKey OR (OIV != null and OIV.length > 0)
			ОШИБКА! ОВИ принимается только на первом шаге шифрования

		if RE != 0 and SecondKey
			ОШИБКА! ОВИ принимается только на первом шаге шифрования. RE должен быть равен нулю

		if R < MIN_ROUNDS OR RE < MIN_ROUNDS
			ОШИБКА! Количество раундов не может быть таким малым

		State.SetProgress(1, StartIndexOfKey, key.length)

		var max_key = if SecondKey then MAX_MULTIPLE_KEY else MAX_SINGLE_KEY

		var len  = Минимум(max_key, key.length - StartIndexOfKey)
		var len1 = младший байт от len
		var len2 = старший байт от len
		S[0] = S[0] xor len1
		S[1] = S[1] xor len2

		if Initiated
			for i = [0, len - 1] step 1
				S[i+2] = S[i+2] xor key[i + StartIndexOfKey]
		else
			for i = [0, len - 1] step 1
				S[i+2] = key[i + StartIndexOfKey]

		if OIV != null and OIV.length != 0
		
			if RE == 0
				ОШИБКА Рекурсивный вызов не принимает вектора инициализации

			var len1 = младший байт от OIV.length
			var len2 = старший байт от OIV.length
	
			S[2050] = S[2050] xor len1
			S[2051] = S[2051] xor len2
	
			for i = [0, OIV.length - 1] step 1
				S[i+2052] = OIV[i]

		tweak[0] += 1253539379

		if !SecondKey
			tweak[1] += key.length

		// После ввода значений делаем шаг VinKekFish
		VinKekFish.Step(R, S, tweak)

		len = StartIndexOfKey + len

		if len < key.length
			VinKekFish.ВводКлюча
			(
				key: 			 key,
				key.length: 	 key.length,
				StartIndexOfKey: len,
				Initiated: 		 true,			// !
				SecondKey:		 true,			// !
				R:				 RM,			// !
				RE: 			 0,				// !
				RM:				 RM,
				OIV: 			 null,			// !

				S: S, b: b, c: c, tweak: tweak, State: State
			)

		// Завершающая стадия ввода всех частей ключа
		if !SecondKey
			State.SetProgress(2, 0)

			// Защита от обратного преобразования для вычисления ключа шифрования
			// После ввода всех блоков ключа, выполняется перезапись 4096 битов информации нулями
			// И делается шаг алгоритма
			VinKekFish.Input(data: null, length: 0, Overwrite: true)
			VinKekFish.Step(RE, S, tweak, b, c)
			
			State.SetProgress(2, 1)


	конец.


# Ввод данных

Ввод данных осуществляется поблочно, блок размером BLOCK_SIZE байтов.
При вводе нулевой байт состояния с помощью xor принимает младший байт размера вводимого блока в байтах.
Первый байт состояния с помощью xor принимает старший байт размера вводимого блока в байтах.
При вводе в режиме OVERWRITE устанавливается старший бит размера вводимого блока данных.

Второй байт состояния с помощью xor принимает счётчик режима.

## Ввод в режиме Sponge (губка)
В режиме ввода Sponge (губка) ввод происходит с помощью xor. Байты состояния [3; 514] входят в операцию xor с вводимым блоком байтов.


## Ввод в режиме OVERWRITE (режим перезаписи)

В режиме OVERWRITE (режим перезаписи) ввод происходит с помощью простой перезаписи состояния. Байты состояния [3; 514] перезаписываются вводимыми байтами. Если вводимых байтов меньше, чем 512 (BLOCK_SIZE), то остальные байты состояния перезаписываются нулями.

