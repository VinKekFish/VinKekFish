# Работа с каскадами

В этом файле расположены описания дублирующих алгоритмов повышенной стойкости. Они также не проходили проверку криптоаналитиками.

Обозначение log подразумевает log2 (логарифм по основанию два)

# Предупреждение

Данный алгоритм не проходил независимого криптоанализа и сделан любителем в сфере криптографии.
Часть формул (для количества раундов, стойкости и т.п.) взяты из общих предположений без вывода.
Если вы хотите использовать данный алгоритм, дублируйте шифрование другими, более надёжными, средствами шифрования.


# Каскад keccak (каскадная губка)
6. Полностью независимое от VinKekFish шифрование каскадом keccak


## 6.1. Одинарный каскад keccak
Выполняется инициализация нескольких губок keccak ключами и синхропосылками (как минимум, верхняя губка). При этом губки строятся каскадами.
keccak0
keccak1
keccak2
...

Верхняя губка подаёт (в режиме duplex) свой выход на нижнюю (в качестве входа), нижняя подаёт свой выход на ещё более нижнюю, и так далее.
Каждый шаг губка впитывает вывод от более верхней губки и выдаёт вывод на более нижнюю губку.
Вывод самой нижней губки подаётся на вход верхней губки, обеспечивая обратную связь в каскаде.
Выход самой нижней губки является и выходом всего алгоритма в целом.

Шагом каскада является выполнение шагов губки для всех губок алгоритма (с распространением информации по каскаду).

При этом, данные, которые подаются в обратную связь должны быть любым способом изменены для того, чтобы обеспечить самостоятельный уход каскада от возможного состояния каскада, где состояния всех губок будут равны.
Для этого первое 8-мибайтовое слово губки может быть приращено на 1. Информация, попадающая на выход, не требует такого приращения. Приращение осуществляется только в обратной связи для того, чтобы обеспечить отличие обратной связи от прямой передачи информации вниз по губке.
Вместо приращения на 1 информация может быть подвергнута шифрованию TreeFish (с приращением его tweak на единицу каждый раз или без такового; ключ - любой, хоть ноль). При этом недостающая часть блока равна нулю в первый раз и равна предыдущему выходному блоку в следующий раз.
#### Таким образом, вычисление обратной связи с блоком TreeFish следующее.
1. Инициализировать доп. ключом TreeFish. Tweak инициализировать нулём или другим значением. (см. также "Генерация ключа для ThreeFish в обратной связи")
2. Вход для ThreeFish - инициализировать нулём
3. Ввести в левую половину блока TreeFish (блока открытого текста) выход с самой нижней губки keccak
4. Зашифровать блок открытого текста TreeFish и подать его на вход каскада. Выполнить шаг каскада
5. Вход для ThreeFish - сдвинуть левую половина блока в правую половину. Левую половину инициализировать выходом с самой нижней губки keccak. Tweak[0] прирастить на единицу (не обязательно; можно работать с tweak как угодно).
6. Перейти к пункту 4 (каждый шаг каскада выполяется одно шифрование TreeFish).

Вместо сдвига левой половины в правую половину допускается просто записать информацию в свободную половину входа.


Дополнительные требования
1) В каскаде строго не менее 3-х губок для любой схемы шифрования.

countStepsForKeyGeneration= 2\*k\*log(k)+1
countStepsForHardening    = log(k+1)

#### Инициализация с вводом ключа и синхропосылки опосредованно (в самую верхнюю губку):
1. W=log(k+1)
2. Ввести в самую верхнюю губку часть синхропосылки (512-ть битов или менее)
3. Провести countStepsForKeyGeneration шагов каскада (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки, с учётом возможной потери информации при взаимодействии данных).
4. На следующих шагах вводить в губку данные через xor с обратной связью.
1) Взять выход "Out" самой нижней губки (512-ть битов). Выход берётся также, как для обычной обратной связи (с приращением на единицу).
2) Применить для нового блока данных (синхропосылки или ключа) xor с обратной связью. Таким образом мы вычислили изменённую обратную связь
3) Подать значение изменённой обратной связи в верхнюю губку (не проводя шагов губки).
4) Провести countStepsForKeyGeneration шагов каскада. Перейти в шагу 4.1 или, если данные для инициализации закончились, перейти к шагу 5.
5. Ввести в режиме OVERWRITE обратную связь в верхнюю губку. Провести ещё countStepsForKeyGeneration шагов каскада с обратной связью через xor. Считать губку проинициализированной

Формула countStepsForKeyGeneration обусловлена тем, что необходимо как провести через обратную связь ввод данных на верхнем уровне, для чего требуется k шагов алгоритма, так и тем, что необходимо также провести через губку ещё и потерянную при передаче от слоя к слою энтропии. Для учёта этого взят коэффициент 2\*log(k)/log(2).


#### Инициализация с вводом ключа непосредственно в губки:
1. W=log(k+1)
2. Ввести синхропосылку опосредованно (см. выше) либо разделить её на 512-тибитные блоки (или меньшие равные части) и ввести в каждую губку по отдельности.
4. Разделить ключ на 512-ти битные блоки.
5. Ввести в каждую губку свой блок так, как будто происходит отдельная инициализация только этой губки. Если ключевой информации не хватает, выполнять инициализацию в каскаде снизу вверх, пока хватает ключевых блоков (если последний блок не кратен 512-ти, всё равно его можно ввести). Если блоков слишком много, повторить инициализацию губок далее (после шага каждой губки ввести новые блоки) либо остаток ввести опосредованым способом. При этом, в любом случае, инициализация выполняется так, как будто каждая губка инициализируется отдельно. То есть пока никакого каскада не существует.
4. После инициализации губок провести countStepsForKeyGeneration шагов каскада.


#### В режиме генерации ключа (или в режиме шифрования небольшого количества важных данных), выход берётся следующим образом:
1. W=log(k+1).
2. Провести после предыдущего взятия выхода (или инициализации) countStepsForKeyGeneration шагов каскада вхолостую (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки, с учётом возможной потери информации при взаимодействии данных).
3. Сделать ещё один шаг каскада и взять ⌊64/W⌋ байтов из выхода. Перейти к пункту 2.




#### В режиме обычного шифрования выход берётся следующим образом:
1. W=log(k+1)
2. Взять ⌊64/W⌋ байтов из выхода (на каждом шаге губки из каждой губки keccak)


#### В режиме гаммирования с обратной связью по открытому тексту использовать следующий режим:
1. W=2, либо W=log(k+1) для повышения стойкости. Для режима генерации ключа с вводом рандомизирующей информации W=k. Провести инициализацию губки, как описано выше
2. Провести k шагов каскада вхолостую (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки). Для режима генерации ключа - countStepsForKeyGeneration шагов. (все шаги проводятся с обратной связью)
3. Взять ⌊64/W⌋ байтов из самой нижней губки на выход каскада
4. Сделать 1 шаг каскада вхолостую. Для режима генерации ключа - countStepsForKeyGeneration шагов.
5. Взять обычный выход обратной связи Out. Пропустить Out через xor с открытым текстом (или с рандомизирующей информацией). Дать полученные данные на вход самой верхней губки (вместо обычной обратной связи).



#### Генерация ключа для ThreeFish в обратной связи
1. W=log(k+1) либо W=2 (для меньшей стокойсти)
2. Провести инициализацию губки любым методом с обратной связью в виде операции +1 к младшему 8-мибайтовому слову (или другой изменяющей обратную связь операции; в том числе, годится ThreeFish с любым, даже нестойким, ключом)
3. Взять ⌊64/W⌋ байтов выхода для ключа ThreeFish.
4. Провести countStepsForKeyGeneration шагов каскада в холостую (с обратной связью)
5. Если ключ ThreeFish всё ещё не вычислен, перейти к пункту 3
6. Теперь ввести в действие обратную связь с вычисленным ключом ThreeFish.
7. Выполнить countStepsForKeyGeneration шагов каскада
8. Если ключ был вычислен в первый раз, то перейти к пункту 3 и заново вычислить ключ ThreeFish, используя уже вычисленный ключ ThreeFish в качестве ключа для ThreeFish-преобразователя обратной связи
9. Если ключ был вычислен во второй раз, ввести новый ключ ThreeFish и провести countStepsForKeyGeneration шагов каскада для повторной инициализации (без какого-либо сброса состояний).



## 6.2. Двойной каскад keccak-Treefish
Создаётся два параллельных каскада, аналогичных описанным в пункте 6.1. k - количество уровней каскада.
keccak0L	keccak0R
keccak1L	keccak1R
keccak2L	keccak2R
keccak3L	keccak3R
...

Основной ключ данного каскада состоит из 2\*k\*512 битов (или удвоенного значения).
Дополнительный ключ данного каскада состоит ещё из (k+1)\*1024 битов.

Ключ/синхропосылка может быть подан в каждую губку отдельно либо опосредовано через самую верхнюю губку (аналогично одиночному каскаду). Синхропосылка - через tweak каждого TreeFish (или также опосредовано). Также синхропосылка может инициализировать отдельно каждую губку. После этого (без каскадирования) в эти губки вносятся части ключей шифрования (как будто губки одиночные).
Далее, на каждом шаге две верхние губки дают данные для одного блока TreeFish. TreeFish выполняет шифрование этих блоков и даёт на выход блок из 1024-х битов. Этот блок разделяется на две нижних губки (на их входы).
В качестве ключевой информации TreeFish принимает ключ 1024 бита. При этом кроме стандартного ключа в 1024 бита в tweak может быть записана либо ключевая информация, либо синхропосылка.

Обратная связь.
С обоих самых нижних губок информация поступает в Treefish аналогично более верхним слоям и, затем, переходит на самые верхние губки (обратная связь).
В случае необходимости ввода информации в каскадную губку, половина ввода вводится через xor с блоком, полученным от обратной связи, в левую (самую верхнюю) губку, а половина - в правую губку (либо ввод осуществляется только в левую губку).
В ThreeFish обратной связи tweak нужно приращать каждый шаг касакада. Причём tweak у других частей каскада приращаться не должен или должен приращаться по другому алгоритму (чтобы обеспечить выход из режима, где все губки каскада случайно имеют одни и те же состояния)

Выход.
С самых нижних губок информация поступает на выход. Для этого две губки дают 1024-ре бита информации для шифрования ещё одним ключом ThreeFish (без преобразования для обратной связи). Tweak и key[16] берётся отдельно из блока обратной связи.
После этого выходной блок ThreeFish используется для получения выхода.


В случае, если ключевой информации не хватает для ключей Threefish, они могут быть проинициализированны такой же двойной каскадной губкой, однако ключевые блоки в такой губке могут быть взяты с помощью дополнительного шага этого же уровня каскада.

Алгоритм такой инициализации
1. W=log(k+1)
2. Ввести ключи и синхропосылки напрямую, так, как будто каскада нет (разбив ключ и синхропосылку на части либо только ключ на части, а синхропосылку использовать одну и ту же).
3. В каждом уровне каскада сформировать свой выход (с помощью шага губок). Этот выход является ключом ThreeFish
4. Провести не менее чем countStepsForKeyGeneration шагов каскада
5. i = 0
6. Взять выход левой губки на уровне i и поместить его в левую часть ключа ThreeFish (перезаписав уже существующую часть ключа), работающего после уровня i
7. Провести не менее чем countStepsForKeyGeneration шагов каскада. Выполнить i++ (приращение i на единицу). Повторить пункт 6.
8. После прохождения всех левых губок перейти на шаг 5 и повторить шаги уже для правых губок и правых частей ключей ThreeFish. После инициализации правых частей ключей ThreeFish (с выполнением countStepsForKeyGeneration шагов каскада после последней перезаписи части ключа) алгоритм проинициализирован полностью без дополнительных шагов.
9. Для увеличения стойкости, можно пройти алгоритм повторно, начиная с пункта 4


Для ключа длиной L битов целесообразно использовать k=⌈L/2048⌉.


docs::docs:rQN6ZzeeepyOpOnTPKAT:
## 6.2. Кратный каскад keccak-Treefish

Аналогично, только создаётся множество губок параллельно (ширина каскада не 2, а более).

Минимальное ширина каскада рассчитывается по формуле wide=⌈log(k+1)⌉.
В реализации tall=k (высота каскада), wide - ширина каскада.
Минимальная ширина - 2. Минимальная высота - 3. Высота всегда должна быть не менее ширины, т.к. именно высота определяет стойкость алгоритма (количество преобразований, которые нужно разрешить).

W=log(k+1) - коэффициент запаса
Ввести не более чем Wn=⌊64/W⌋ байтов в каждую губку. Остальной ввод взять из обратной связи.
Аналогично, вывод из каждой губки каскада берётся не более чем Wn=⌊64/W⌋

Количество шагов для ввода/вывода (пропуски ввода/вывода, инициализация) в/из каскада берётся аналогично обычному каскаду.


### Ввод данных
docs::docs:DAHCEPXmAXk11dSEji7s:
Ввод данных осуществляется в каждую губку не более чем по Wn байтов.
Данные разбиваются для губок поровну.
То есть, если вводится N байтов, то в каждую губку вводится ⌈N/wide⌉ байтов. В поледнюю губку вводится остаток от того, что ещё не введено (если wide>=64, то, теоретически, возможно, в последнюю губку вообще не будет никакого ввода, а в предпоследнюю будет частичный).

Общее количество вводимых байтов за один шаг каскадной губки N - не более, чем maxDataLen=Wn\*wide

При вводе данных всегда делается дополнительный шаг губки, т.к. часть обратной связи губка теперь не получила, а данным нужно хорошо распространиться по всему каскаду. То есть если введён хотя бы один байт пользовательских данных, то губка делает ещё один шаг к тем шагам, которые ей положено. То есть шаг губки при вводе данных сразу считается двойным всегда, даже если при описании это не описано.
Это реализуется сразу же внутри алгоритма шага.


#### Обратная связь на вводе данных
Остальные данные, которые могут быть введены в губки, вводятся из обратной связи.
Если пользовательские данные не вводятся, то из обратной связи данные в верхние губки вводятся последовательно, по блокам 64-ре байта.
Если пользовательские данные вводятся, то данные вводятся также по блокам 64-ре байта. Однако, из каждого блока обратной связи берутся только первые 64-⌈N/wide⌉ байтов (или менее), которые вводятся в губку. То есть, обратная связь заполняет все значения, которые не были заполнены пользовательским вводом.

На самом первом шаге вместо данных обратной связи просто берутся нули (на вводе xor они не должны влиять на результат вообще).
TODO: описать алгоритм более конкретно
Каждый шаг, кроме первого, вход с обратной связи поблочно шифруется ThreeFish1024 (с разными ключами для каждого блока). Затем транспонируются, чтобы обеспечить ввод в разные губки верхнего уровня данных из разных ThreeFish-блоков.

Если ширина блока обратной связи не кратна блоку ThreeFish, то ThreeFish оставляет нешифрованными часть данных. Однако, это не должна быть часть данных, которые ушли на выход: они все должны быть зашифрованы.


docs::docs:CJXTMlFBHbtxFNSpqeC8:
##### Инициализация с вводом ключа и синхропосылки опосредованно (в самую верхнюю губку):
0. Если есть инициализция для ThreeFish, проинициализировать ключи и твики ThreeFish обратной связи
1. W=log(k+1). Wn = ⌊64/W⌋. maxDataLen=Wn*\wide
2. Ввести maxDataLen битов в губку.
3. Для синхропосылки просто провести шаг (это - двойной шаг, как описано в правилах ввода данных). Для ключа провести countStepsForKeyGeneration шагов каскада (для того, чтобы обратная связь по данным, сгенерированным на шаге взятия выхода, прошла через все слои губки, с учётом возможной потери информации при взаимодействии данных). Из countStepsForKeyGeneration шагов - первый шаг двойной (на вводе данных).
4. На следующих шагах вводить в губку данные аналогично (обратная связь работает, даже если не проинициализирована), порциями по maxDataLen.
Перейти в шагу 2. Если данные для инициализации закончились, перейти к шагу 5.
5. Ввести в режиме OVERWRITE обратную связь в верхнюю губку (и сделать шаг). Провести ещё countStepsForKeyGeneration шагов каскада с обратной связью через xor. Считать губку проинициализированной

Сначала в губку вводится синхропосылка, затем ключ. Предположительно, это позволяет не создавать повторяющийся радиошаблон при работе с одним и тем же ключом (чтобы не показывать, что ведётся работа именно с этим ключом).
Синхропосылка отделяется от ввода ключа countStepsForHardening холостых проходов в режиме xor (обычный ввод в губку без перезаписи). Если синхропосылки нет, то перед вводом ключа ничего не делается.


docs::docs:Wt74dfPfEIcGzPN5Jrxe:
##### Генерация ключа для ThreeFish в обратной связи
1. W=log(k+1)
2. Провести инициализацию губки ключом (как описано выше). В обратной связи ввести 0 или другие значения в ThreeFish.
3. Взять maxDataLen байтов выхода для ключа ThreeFish.
4. Провести countStepsForKeyGeneration шагов каскада в холостую (с обратной связью)
5. Если ключ ThreeFish всё ещё не вычислен, перейти к пункту 3
6. Теперь ввести в действие обратную связь с вычисленным ключом ThreeFish.
7. Выполнить countStepsForKeyGeneration шагов каскада. Ещё один раз в режиме OVERWRITE и ещё countStepsForKeyGeneration в обычном режиме.
8. Если ключ был вычислен в первый раз, то перейти к пункту 3 и заново вычислить ключ ThreeFish, используя уже вычисленный ключ ThreeFish в качестве ключа для ThreeFish-преобразователя обратной связи. Если необходимо, генерацию ключа повторить снова.
9. Считать губку проинициализированной


### Вывод данных
Данные берутся подряд из губок нижнего слоя в один массив.
Затем данные транспонируются по 64 байта в строке.
То есть, если исходный массив был [0 1 2 3...], то итоговый массив при wide=3 должен быть [0 64 128 1 65 129 2 66 130 3 67 131]
На пользовательский выход могут быть поданы не более чем maxDataLen=Wn\*wide первых байтов из этого массива.


