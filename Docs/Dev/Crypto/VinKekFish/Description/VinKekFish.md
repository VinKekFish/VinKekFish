Более точное описание реализаций см. в файле .\VinKekFish\GeneralOfDetails.md
Здесь описание примерное

# Незаконченные работы
Тест на длинну гаммы в режиме Overwrite
Проверить в тесте на то, что 1253539379 даёт длительный прирост (без приращения, с умножением).
Проверить по списку типовых ошибок

Сделать статистические тесты (см. в конце)

Сгенерировать таблицы transpose\* и просто задать их. Ну или алгоритм сделать.

Сделать реализации и протестировать их


# Алгоритм VinKekFish

Алгоритм имеет криптографическое состояние и Tweak (настройка для ThreeFish). Для пользователя доступна часть криптографического состояния.
Построен аналогично keccak на основе конструкции Губка (Sponge) и на основе криптографических преобразований keccak и ThreeFish.

Все известные алгоритмы берутся полнораундовыми, так как неполнораундовые с большей вероятностью внесут какие-либо паразитные связи между битами, не соответствующие идеальным перестановкам.

# Полный шаг губки
Перед первым шагом губки (или дуплекса) следует первичная инициализация
Она выполняется для губки (или дуплекса) один раз за всё время её работы. В дальнейшем названия "губка" и "дуплекс" считаются эквивалентными (т.к. работают в данном алгоритме одинаково).

После первичной инициализации следуют шаги шифрования.
Для каждого шага следует:
1. Вычисление нового Tweak для следующего шага
2. Непосредственный ввод данных, изменение Tweak относительно вводимых данных, режима ввода и логического режима шифрования
3. Предварительное преобразование
	3.1. Перестановка для распределения впитанных данных
	3.2. Поблочное шифрование TreeFish
	3.3. Перестановка
4. Основной шаг алгоритма (криптографические раунды)
5. Заключительное преобразование:
	5.1. Заключительная рандомизация, состоящая в поблочном keccak и перестановке. Повторяется некоторое количество раз.
6. Перестановка для объединения данных для вывода (объединена с заключительным преобразованием)
7. Вывод данных

В случае необходимости, для повышения защищённости вывода от ошибок VinKekFish, вывод данных может быть пропущен через губку keccak.
В таком случае, губка может быть инициализирована полным ключом шифрования для VinKekFish, а затем однократным выводом с первого раунда VinKekFish (также, см. ниже).

# Использование губки
Примерное использование губки.

1. Ввод ключа (или открытого вектора инициализации). Рекомендуется вводить сначала открытый вектор инициализации (синхропосылку)
2. Ввод открытого вектора инициализации (или ключа)
3. Ввод данных, вывод гаммы
4. Вывод гаммы и/или хеша

## Например, гаммирование с обратной связью по открытому тексту.

1. Ввод ключа, счётчик режимов 1. Инициализация Tweak любым значением. Шаг губки.
2. Ввод ОВИ, счётчик режимов 128. Шаг губки.
3. Вывод блока гаммы (и применение её к открытому тексту).
4. Ввод открытого текста. Счётчик режимов 0. Шаг губки.
5. Вывод блока гаммы
6. И так далее

Реальные схемы шифрования см. в файлах рядом: (пока таких файлов нет)

# Размер криптографического состояния

Размер состояния K*25600,
где K - нечётное натуральное число (1 или более; 1, 3, 5, 7 и т.д. до 19 включительно).
Для K > 11, при перемешивании блоков keccak за один шаг перемешивания невозможно перемешать блоки так, чтобы хотя бы один байт каждого блока был бы представлен в каждом новом блоке (для keccak; для ThreeFish это K=5, однако заключительные преобразования основаны только на keccak). Это может повлечь некоторое снижение стойкости алгоритма при том же количестве раундов (а может и не повлечь).
В связи с этим, рекомендуется использовать алгоритм при K = 1, 3, 5, 7, 9, 11.

Нечётность числа следует из того, что тогда общее количество блоков не делится на два. Для количества блоков 25 следует, что threefish применяется, в частности, к парам (0;12), (12,24), (13,0) [это пары (номер блока, из которого берётся ключ; номер блока, из которого берётся текст для шифрования)].
Если бы блоков было чётное количество, то threefish применялся бы один раз в паре (0;12), а один раз к паре (12; 0). То есть было бы два зависимых между собой криптографических преобразования, которые не были бы зависимы от других блоков. Это упростило бы криптоанализ и уменьшило бы диффузию между блоками.

При нечётном K при преобразовании 0-ого блока ключ берётся из 12-ого блока. Но ключ из 0-ого блока берётся для преобразования 13-ого блока. То есть при многократном преобразовании, блоки будут сами собой перемешивать данные даже без таблиц перестановок и нет ярко выраженной зависимости между двумя блоками. Данные не будут зацикливаться только на одной паре блоков.

Для K > 19 индексы не умещаются в 2-хбайтовых числах, а перемешивание становится всё хуже, поэтому алгоритм использовать не целесообразно и он не разрабатывается для таких значений.

# Размер Tweak
Tweak из ThreeFish используется в служебных целях, но может быть проинициализирован и пользователем.
Как определено в ThreeFish, размер Tweak составляет 16-ть байтов.
В оригинальном ThreeFish третье 8-мибайтовое слово t2 равно t0 ^ t1 (расширение tweak).
В VinKekFish t2 = t0 ^ t1 ^ блок_губки.

Расширение ключа key не производится. Вместо этого берётся лишний блок шифрования.

# Первичная инициализация

Первичная инициализация проходит один раз перед началом использования губки.
Дополнительная инициализация ключами или вектором инициализации происходит в шаге алгоритма (подаваемыми на вход губки или в начальный tweak)


## Tweak

Служебный Tweak инициализируется алгоритмом шифрования (изначально заполняется нулями и затем изменяется при шифровании для каждого раунда, блока и шага губки).
Пользовательский Nonce лучше инициализировать непосредственно в губку, чтобы обеспечить большую радномизацию. То есть Nonce вводить в губку для впитывания, а не в tweak.
В целом, tweak может быть проинициализирован и пользователем.

Положено, что Tweak известен злоумышленнику. Если он не известен, то считается, что злоумышленник может его вычислить.
Так что в Tweak не должно быть конфиденциальных значений, которые не должны быть раскрыты (в целом, это не запрещает инициализировать tweak дополнительным ключевым значением, которое более нигде не используется). Хотя раскрыть хорошо проинициализированный tweak, скорее всего, злоумышленнику будет сложно.


## Криптографическое состояние

### Сложная инициализация

Криптографическое состояние разделяется на строки по 16-ть байтов.
Таблица заполняющих чисел fillTable
0  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61

Далее, для i-ой строки каждого столбца происходит заполнение байта значением (i+1)\*(fillTable[N]), где N есть шаг алгоритма для данного столбца (начиная с нуля).
То есть для нулевой строки, копируется содержание fillTable, для первой строки - содержание fillTable копируется с умножением на два.

Например, для состояния из 32-х байтов состояние будет инициализировано следующими значениями
003 007 010 013 017 019 023 029 031 037 041 043 047 053 059 061 006 014 020 026 034 038 046 058 062 074 082 086 094 106 118 122

Таким образом обеспечивается заполнение всего начального состояния уникальными 16-ти байтовыми значениями для большей начальной рандомизации. Так как алгоритм поблочный, это поможет блокам сильнее отличаться друг от друга на первом шаге.


### Простая инициализация
Пользователь вводит любое значение для инициализации (в том числе и нули), после этого делает шаг губки.
Теперь губка готова к использованию (к вводу ключа и т.п.).


### Инициализация нулями
Вместо указанного выше алгоритма, допускается инициализировать начальное состояние нулями.

В реализациях данного проекта всегда принята инициализация нулями или простая инициализация.


# Вычисление нового Tweak для следующего шага

Если внутреннее состояние губки инициализировано нулями, Tweak не должен быть 0.
При этом, tweak может быть проинициализирован пользователем любым значением. Если он не проинициализирован любым значением, то tweak проинициализирован нулями.

Перед каждым шагом, в том числе перед первым шагом губки осуществляется следующее.
Перед непосредственным вводом данных осуществляется приращение младшего 8-мибайтового слова Tweak (t0) на значение Pi=1253539379 (это простое число, дано в десятичной системе исчисления - в принципе, сюда можно взять любое другое число, лучше - простое). Младшее слово в массиве - первое (младший байт по младшему адресу).
Старшее 8-мибайтовое слово не изменяется (к нему осуществляется приращение при вводе данных). В том числе, бит переноса из младшего слова в старшее не переносится, то есть 8-мибайтовые слова в алгоритме обрабатываются отдельно.

# Непосредственный ввод данных

Ввод данных осуществляется по блокам в 4096*K битов (K*512-ть байтов; то есть длина вводимого блока равна номинальной длине ключа). Блоки вводятся во внешнюю часть криптографического состояния, по одному блоку за раз.
Размер (в байтах) вводимого на текущем шаге блока данных обозначим за r. r имеет размер 2 байта. r вводится в tweak и во внутреннее состояние (описано ниже). Ещё 1 байт (режим ввода) вводится во внутреннее состояние счётчика режимов.
Также в tweak вводятся режимы работы губки (губка или overwrite).

Например, для K = 19 размер ввода (за один шаг губки) ограничен 512*K = 512*19 = 9728 байтов за раз.
Два старших бита размера всегда должны быть пусты, так как туда записываются режимы overwrite (при таком размере это ещё обеспечивается).

## Подробное описание ввода размера и режима

Как вычисляется начальный Tweak описано выше. В том числе, к нему прибавляется число Pi перед каждым шагом губки (в том числе, перед начальным шагом).

* Добавление размера вводимого блока в Tweak
После вычисления нового Tweak (см. выше), к старшему 8-мибайтному слову Tweak добавляется (арифметическим сложением) 2 байта размера вводимого блока (то есть добавляется число r).
* Добавление к старшему байту Tweak
Если ввод осуществляется в режиме overwrite (см. ниже), то к старшему байту старшего 8-мибайтового слова добавляется ещё 1 (то есть добавляется 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову).
В режиме губки к старшему байту ничего не добавляется. Режим padding в режиме overwrite в tweak никак не обозначается.
* Добавление значения счётчика режимов к Tweak
Кроме этого, в любом из режимов, к 3-ему (нумерация, начиная с 1) по старшинству байту старшего 8-мибайтового слова добавляется значение счётчика режимов. Например, если счётчик режимов 3, то добавляется 0x0000_0300_0000_0000 (regime << 40).

* Ввод пользовательских данных
Ввод в криптографическое состояние может осуществляться с операцией побайтового xor (в режиме губки). Первые байты (младшие байты) идут по младшим адресам. Xor осуществляется непосредственно с первыми K*512-тью байтами внутреннего состояния.
Точнее, сначала идёт два байта количества вводимой информации (длина указывается в байтах), потом один байт счётчика режима, а потом ввод (то есть, для K=1 индексы не от 0 до 512 не включая, а от 3 до 515 не включая; для K=3: от 3 до 1539 не включая).
Также ввод может осуществляться простой перезаписью байтов состояния губки вместо xor (режим overwrite) на том же месте. Такой ввод рекомендуется делать в качестве необратимого преобразования для предотвращения вычисления ключа при криптоанализе.
В режиме overwrite байты количества вводимой информации и счётчика режима всё равно вводятся с помощью xor.


padding (заполнение) отсутствует, т.к. в tweak и в первые два байта состояния осуществляется ввод размера вводимого блока. То есть xor осуществляется с вводимыми данными и больше ничего нигде не вводится (кроме 3-х байтов размер и счётчика режима).

В режиме overwrite padding состоит в следующем.
Перезаписывается внешнее криптографическое состояние вводимым массивом байтов.
Если массив байтов недостаточно длинный (менее, чем K*512 байтов), то осуществляется перезапись каждого оставшегося байта (из внешнего состояния) теми же значениями, как при инициализации губки (либо нулями).
Например, если осуществлён ввод числа 01 08 03, то первые 16-ть байтов (точнее, байты [3 .. 18]) при сложной инициализации будут следующими (десятичная система)
001 008 003 013 017 019 023 029 031 037 041 043 047 053 059 061

Однако, это только если выбран сложный вариант инициализации.
Если выбран способ инициализации нулями - то байты просто перезаписываются нулями (допускается перезаписывать нулями при любом режиме инициализации).
001 008 003 000 000 000 000 000 000 000 000 000 000 000 000 000

(В реализациях данного проекта всегда принято заполнение нулями на данном этапе)

Режим overwrite без padding.
В таком случае осуществляется ввод блока информации на длину этого блока. Если блок слишком мал (меньше длины блока внешнего состояния), то никакая перезапись не осуществляется.


Первые два байта криптографического состояния получают xor (всегда именно xor вне зависимости от режима) с числом r (количеством вводимых байтов), и ещё следующий байт получает xor со счётчиком режимов.
Старший бит числа r (количества вводимых байтов) устанавливается в 1, если используется режим overwrite. Если overwrite используется без padding (то есть блок ввода не перезаписывается нулями после конца данных), то второй по старшинству бит также устанавливается.
Счётчик режимов определяется разработчиком схемы шифрования. Он может показывать, что именно происходит. Например, счётчик 1 может показать, что вводится вектор инициализации, счётчик 2 - что вводится ключ, счётчик 0 - что вводятся данные и т.п.
Режим overwrite в данном счётчике никак не обозначается.

Допускается обозначать другие особенности ввода изменением неиспользуемых битов числа r (если K мал) или изменением счётчика режимов (если это не вводит неоднозначности при таком использовании).

Счётчик режимов может работать и в любых иных режимах или игнорироваться (быть нулём, то есть ни на что не влиять, так как a xor 0 = a).

Пример алгоритма назначения счётчика режимов. Счётчик режимов выбирается следующим
1, 2, 3, 4 ... - для блоков ключей (при достижении 127 следующее значение - 0)
128, 129, 130, 131 - для блоков открытых векторов инициализации
255 - для отбоя данных от ключа в режиме overwrite
0 - для остальных вводимых данных.

Ещё один, более простой пример.
Для блоков ключей ввод с режимом 1.
Для блоков открытого вектора инициализации: ввод с режимом 2.
Для отбоя данных от ключа в режиме overwrite (холостой проход с перезаписью нулями): режим 3.
Блоки данных: режим 0.


## Перестановка для распределения впитывания
Затем выполняется перестановка с помощью таблицы transpose128_3200 (см. ниже). То есть перед раундами шифрования идёт однократная перестановка transpose128_3200 (для K=1; для иных K таблица вычисляется аналогичным образом transpose128_* ).
После этого выполняется однократная поблочная операция treefish, и затем снова transpose128.
После этого начинаются раунды шифрования (основной шаг).


Распределение впитывания идёт вне зависимости от того, впитано ли что-либо или нет.
Tweak в этом распределении никак не изменяется (это твик, входящий на этот шаг и использующийся без изменений в первом раунде). То есть он изменяется только перед самим шагом (ввод данных и числа Pi) и внутри поблочного преобразования, но после шага распределения остаётся неизменным.

Распределение позволяет
1. Избежать значительного влияния злоумышленника (своим вводом) на какой-то конкретный блок шифрования, одновременно не выдавая слишком много байтов при выводе
2. Развязать keccak заключительной рандомизации с первым keccak раундов через применение treefish

## Если ввода не было
Если ввод был нулевого размера, то, из вышеописанного алгоритма, следует следующее.

### В режиме губки
Если ввода не было, к tweak добавляется перерасчёт при начале шага +1253539379 (+Pi) к младшему слову.
В состояние и в старшее слово tweak вводится счётчик режима (если он не нулевой). Т.к. длина вводимых байтов равна нулю, то она ничего не изменяет.
Выполняется "Перестановка для распределения впитывания".

### В режиме overwrite
Если ввода не было, к tweak идёт приращение 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову (и +1253539379 к младшему 8-мибайтовому слову).
В tweak и в состояние вводится счётчик режима (так же, как и в режиме губки).
Все 512-ть первых байтов криптографического состояния перезаписываются нулями.
Выполняется "Перестановка для распределения впитывания".


### Ввод данных на следующий шаг не должен зависеть от выхода данных с предыдущего шага

Запрещено осуществлять ввод данных, которые зависят от полученных от губки данных с этого же шага (это не препятствует режиму обратной связи как по открытому тексту, так и по шифротексту; однако режим обратной связи по шифротексту - это режим обратной связи по открытому тексту в режиме overwrite).
Таким образом, данные, вводимые на этом шаге в губку, должны быть известны ранее (с точки зрения логики, а не времени выполнения), чем будут получены выходные данные от губки на этом шаге.
При режиме обратной связи - это всегда режим обратной связи по открытому тексту.

Это важно для того, чтобы злоумышленник не мог воспользоваться выходом дуплекса для того, чтобы его атаковать.
См. стр. 4 "1.3 Our Contribution" "Full-State Keyed Duplex With Built-In Multi-User Support" https://keccak.team/files/FSKD.pdf.


### Ввод ключа и синхропосылки (открытого вектора инициализации)

Ввод ключевой информации делается с помощью перезаписи, то есть в режиме overwrite. Это связано с тем, что перезапись информации более безопасна с точки зрения ПЭМИН, чем xor.

Ввод ключа до открытого вектора инициализации (синхропосылки) поставляет злоумышленнику данные для анализа данного ключа каждый раз при вводе. Однако, эти данные одни и те же, то есть прибавляют статистику только если оборудование для считывания неточное. В то же время, если оборудование точное - то оно считает ключ полностью либо считает множество данных, являющихся суммой обрабатываемых сигналов в каждый момент времени. За счёт этого, может быть получено довольно много данных.
На следующих шагах (при введении ОВИ) эти данные будут уже преобразовываться с различными данными.
Кроме этого, ввод открытого вектора инициализации возможен в режиме overwrite, что поможет выполнить необратимую операцию и создать неопределённость в отношении ключа для криптоаналитика.


Ввод ключа после открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа, причём каждый раз разные. Однако, в обоих случаях (ввод перед/после), на втором этапе данные будут различны.
В целом, предпочтительнее вводить ОВИ (открытый вектор инициализации) ранее ключа. Так, по крайней мере, не будет ясно видной повторяющейся радиосигнатуры при начале шифрования одним и тем же ключом.


Ввод ключа на первом шаге (до любых преобразований) допускается путём инициализации криптографического состояния этим ключом (то есть простой записи ключа во внутрь состояния или дозаписи с xor), причём размер ключа в таком случае ограничивается лишь внутренним состоянием. Однако, это не рекомендуется (для лучшей рандомизации, лучше вводить ключ по блокам; при этом можно сокращать количество раундов преобразования до 1).
Допускается также одновременный ввод ключа и вектора инициализации тем же путём. Это аналогично инициализации "keyed duplex" в работах по keccak (тоже не рекомендуется).
В таком случае разработчик должен обеспечить недвусмысленное отделение ключа от вектора инициализации, и всего этого от последующих данных. Например, путём фиксирования размера ключа и вектора инициализации. Необходимо также исключить одновременную запись (из разных потоков) в одну линию кеша при инициализации (если инициализацию выполняют несколько потоков), иначе одновременная запись в одну линию кеша повлечёт за собой инвалидацию кешей разных процессорных ядер (незначительное снижение производительности, не более того).

После ввода ключевой информации и ОВИ, рекомендуется всегда делать холостой шаг алгоритма (без ввода данных), чтобы дополнительно отбить ключ. При этом, чтобы затруднить восстановление ключа, холостой шаг может быть сделан в режиме overwrite, то есть с перезаписью части данных нулями (это операция является необратимой и создаёт неопределённость в отношении ключа).

В целом, длина ключа и ОВИ не ограничена, если они вводятся поблочно.


#### Требования к синхропосылке (открытому вектору инициализации)

Синхропосылка:
* может быть неслучайной.
* должна никогда не повторяться (абсолютно обязательно; повторение синхропосылки может повлечь за собой раскрытие данных, поэтому она должна генерироваться как можно более случайно или последовательно с высокой достоверностью)


# Вывод данных

## Перестановка для объединения данных для вывода
После выполнения основного шага алгоритма, выполняется заключительное преобразование (заключительная рандомизация), см. ниже в разделе "Основной шаг алгоритма".

## Сам вывод
Если нужен вывод, то берутся первые K*512-ть байтов состояния (младший байт по младшему адресу).
Перестановка выполняется вне зависимости от того, нужен вывод или нет.


# Основной шаг алгоритма

Основной шаг алгоритма состоит из применения 64-х раундов (или другого количества раундов), состоящих из

0. Вычисление tweakVal
(полураунд 0)
1. Поблочное преобразование keccak (точнее keccak-f)
2. Перестановка P1
3. Поблочное преобразование threeFish
4. Перестановка P2
(полураунд 1)
5. Поблочное преобразование keccak
6. Перестановка P3
7. Поблочное преобразование threeFish (с довычисленным tweakVal)
8. Перестановка P4.

После последнего раунда производится заключительное преобразование - заключительная рандомизация. Применяется поблочная функция keccak-f (аналогично пунктам 1 и 5).
То есть идут следующие преобразования (keccak-f + transpose200)\*(keccak-f + transpose200_8)\*(keccak-f + transpose200)\*(keccak-f + transpose200_8)

Допускается использовать (keccak-f + transpose200)\*(keccak-f + transpose200_8) - то есть 2 шага заключительной рандомизации вместо 4-х.
Для K > 11, в связи с худшим перемешиванием, нужно добавить ещё 2 шага (то есть в сумме, 6 шагов, а не 4).


Для P1 используется rnd (случайная перестановка)
Для P2 используется rnd
P3 - transpose200
P4 - transpose128

Для таблиц перестановок rnd рекомендуется первые 8-мь или 4-ре раунда (и, обязательно, первый раунд), использовать P1=transpose200_8 и P2=transpose128. В реализации допускается и отсутствие использования случайных перестановок (то есть использование таблиц transpose200_8+transpose128+transpose200+transpose128 каждый раунд).

Один или оба из P1 или P2 может быть зависим от дополнительного независимого ключа. Предлагается, P1 как зависимый от независимого ключа. Независимый ключ - это ключ, который развязан с основным ключом с помощью алгоритма не меньшей стойкости, чем заданный, либо получен полностью независимо (то есть из количества энтропии не меньшего, чем стойкость основного ключа). Независимость ключа следует из того, что перестановки легче перехватывать по побочным каналам, чем простые ключевые вычисления (таким образом, такой дополнительный ключ может быть считан по ПЭМИН ранее, чем основной ключ).



Довычисление tweakVal происходит следующим образом (tweakVal в начале шага равно tweak).
Работа ведётся с младшим 8-мибайтовым словом tweak (старшее слово не затрагивается, в том числе, бит переноса с младшего слова на старшее не переносится).
Старшее 4-хбайтовое слово tweak складывается с номером раунда, домноженным на 2 - это номер полураунда (tweak не изменяется, запись производится в tweakVal; tweak по прошествии раунда остаётся таким же, каким был до начала раунда).

Для каждого блока 8-мибайтовое младшее слово складывается с номером блока (начиная с нуля). То есть, для нулевого блока используется TweakVal, для первого блока: TweakVal + 1.

Таким образом, на каждый раунд и для каждого блока TweakVal разный.

На второе преобразование threeFish (пункт №7) дополнительно старшее 4-хбайтовое слово tweak приращается на единицу (tweakVal[1] += 0x1_0000_0000;). То есть старшее слово tweak, по сути, складывается с номером полураунда.


## Поблочное преобразование threefish

Пусть N - количество блоков ThreeFish, которые умещаются во внутреннем состоянии.
Тогда j вычисляется как (i + N/2) mod N.
Например, i =  0; N = 25; =>  (0+12) mod 25 = 12.
Например, i = 12; N = 25; => (12+12) mod 25 = 24.
Например, i = 13; N = 25; => (13+12) mod 25 = 0.


Для блока i выполняется преобразование с ключом из блока j и частью ключа из блока j+1. Причём все блоки берутся из  состояния на момент начала поблочных операций (вывод идёт в отдельный участок памяти). То есть блоки i и j+1 - это блоки, значения которых берутся на момент начала поблочных операций и эти блоки не изменяются.
Расширения ключа в ThreeFish не производятся. Первый (точнее, нулевой) элемент блока j+1 является последним ключевым блоком key[16] для шифрования блока i. Блок j даёт остальные ключевые блоки. (j=последний блок => j+1=0)
Расширение tweak производится по Шнейеру. Берётся tweak[2] = tweak[0] ^ tweak[1].


# Защищённые режимы

## Работа в режиме генерации ключей

В режим генерации ключей предполагается уменьшение вывода алгоритма за один шаг для усложнения криптоанализа.
Для этого из каждого алгоритма с блоком длинной L берётся не более чем ⌈L\/(2\*log(8\*K)+1)⌉ битов состояния.
Число 8 - это коэффициент увеличения стойкости алгоритма (с 1024 битов ThreeFish до 8192 битов VinKekFish при K=1).

Блок Threefish имеет 1024 бита. Выход VinKekFish при K=1 равен 4096 битов. Таким образом имеется 4 блока Threefish, следовательно, общий вывод LL для одного шага при K=1 равен LL=4*L битов. Общая формула LL=4*K*L битов со всех блоков Threefish.
import math
for K in range(1,21,2):
    L=1024
    k=1+2*math.log2(8*K)
    Lk=L/k  # Выход с одного блока
    print(f"{K}:\t{math.floor(4*K*Lk)}\t{math.floor(Lk)}\t({k})")

Вывод алгоритма (L и LL - в битах)
K   LLk     Lk          k
1:	585	    146	(7.0)
3:	1208	100	(10.169925001442312)
5:	1758	87	(11.643856189774725)
7:	2272	81	(12.614709844115207)
9:	2763	76	(13.339850002884624)
11:	3237	73	(13.918863237274595)
13:	3697	71	(14.400879436282183)
15:	4147	69	(14.813781191217037)
17:	4588	67	(15.174925682500678)
19:	5022	66	(15.49585502688717)

То есть, для K=1, вместо 512-ти байтов вывода в штатном режиме в режиме генерации ключей выводится за раз не более 73-х байтов. А для K=11 вывод ограничен 404-мя байтами.

Количество раундов на один шаг VinKekFish берётся не менее EXTRA_ROUNDS.

## Работа в режиме повышенной защищённости

Количество раундов R на один шаг VinKekFish берётся не менее REDUCED_ROUNDS.
Каждый раунд берётся в k=MAX_ROUNDS\*S/R раз меньше байтов вывода, чем штатно положено.
S - коэффициент запаса, не менее 1.



# Защита после вывода

VinKekFish не проверен криптоаналитиками, поэтому, его стойкость находится под сомнением.
Чтобы уменьшить риски, можно защитить вывод. Однако это не обязательно.


## Работа с VinKekFish
1. Если используется генерация ключевой информации или ОВИ из основного ОВИ и основного ключа.
1.1. Для генерации 512 битных ключей и ОВИ

Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.
Взаимозависимость таких ключей - 512 битов (VinKekFish эту стойкость не увеличивает).

Для усиления защиты, в keccak duplex может быть заранее введён дополнительный ключ. Вместо дополнительного ключа может быть использован следующий алгоритм:
a.1) Ввести в keccak поблочно весь основной ключ (после каждого блока выполнять преобразование keccak), либо ввести специальный дополнительный ключ keccak (последний вариант более стоек)
a.2) Выполнить преобразование VinKekFish (включая ввод основного ключа в VinKekFish)
a.3) Ввести в keccak поблочно выход от преобразования VinKekFish (после каждого блока выполнять преобразование keccak)
a.4) После этого выполнить преобразование VinKekFish и преобразование keccak без ввода данных. Оба преобразования выполняются в режиме overwite и другим счётчиком режимов.
Считать VinKekFish и keccak проинициализированными

После этого выходные данные берутся из keccak без применения VinKekFish (или с применением VinKekFish аналогично пункту 1.3).


Специальный дополнительный ключ допустимо генерировать с помощью keccak из основного ключа и каких-либо дополнительных данных, использующихся только при генерации этого ключа, после чего keccak подвергается перезаписи в режиме overwrite для обеспечения дополнительной необратимости.


1.2. Пункт исключён.

1.3. Для генерации 1024-битный ключей и ОВИ.
ThreeFish
Сгенерировать дополнительный ключ 1024-ре бита (при генерации основного ключа).
1) Ввести основной ключ (либо ещё один дополнительный ключ) в keccak. При этом, каждый вводимый блок зашифровать блочным ThreeFish с дополнительным ключом перед вводом в keccak.
2) Аналогично пункту 1.1.а.2) выполнить над основным ключом преобразование VinKekFish и ввести вывод VinKekFish в keccak. Каждый блок, полученный от VinKekFish, шифровать ThreeFish с дополнительным ключом.
3) Выполнить преобразование аналогично 1.1.а.4).

Выходные данные берутся следующим образом.
Выполняется преобразование VinKekFish. Затем поблочно шифруется ThreeFish. Затем подаётся в keccak. Каждые два входных блока (по 512-ть битов) из keccak можно получить 512-ть битов выхода.


2. Генерация гаммы, стойкостью 512 битов.

Аналогично 1.1. Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.


3. Генерация гаммы, стойкостью 1024 бита. Полагаемся на предположение, что VinKekFish обеспечивает такую стойкость совместно с защитой.

3.1. Исключён.

3.2. Аналогичо 1.3.


4. Универсальный ослабленный вариант. Каждый вывод VinKekFish полностью вводится в keccak duplex по 64-ре байта за ввод. На один полный вывод VinKekFish приходится 64 байта вывода. Эти 64 байта, правда, могут быть независимы друг от друга только на 1024 бита стойкости из-за того, что они вводятся в один и тот же keccak. Но каждый блок будет развязан.
Очень медленный вариант.
4.1. Как более быстрый вариант вместо ввода в keccak полного вывода VinKekFish, может быть осуществлён ввод только 1024 битов информации.


5. Аналогично 1.1. При этом формируется отдельная гамма с помощью одного VinKekFish без защиты keccak, и отдельная гамма с помощью другого VinKekFish с защитой keccak. Ключ для keccak вводится основной, как и в 1.1.
Чтобы два состояния VinKekFish отличались друг от друга необходимо использовать два разных ключа.


## Работа с каскадом keccak

Вариант №6 описан в файле [cascade.md](cascade.md)


## Рекомендация для дублирующих алгоритмов

С точки зрения оптимальной защиты, можно создать один (или два) keccak duplex и, после первого шага дуплекса VinKekFish, проинициализировать его вводом из VinKekFish (200 байтов ввода, остальные байты выбрасываем либо ещё 200 берём для ОВИ во второй дуплекс). Далее keccak duplex может работать самостоятельно на создание ключей и ОВИ для дублирующего защитного шифрования. А VinKekFish будет использоваться независимо.
Разумеется, здесь есть доверие VinKekFish в плане генерации ключевой информации для дублирующего duplex.

### Использование имитовставок

Так как есть недоверие алгоритмам, то есть и проблема, связанная с тем, что ключ, используемый для шифрования или имитовставки (хеша) может быть вычислен, или может быть определено, что два шифротекста подписаны одним ключом.
Для шифрования проблема решается просто: все гаммы шифров накладываются друг на друга.

Для хешей проблема может решаться по-другому.
1. Большая часть хешей может быть уже зашифрована всеми алгоритмами. То есть должна быть защищена шифрованием.
2. Самые внешние хеши должны использовать одноразовый ключ, восстановление которого не может дать возможности понять, каким именно мастер-ключом подписан данный шифротекст. Ключ должен быть сгенерирован так, чтобы при уязвимости одного алгоритма, ключ всё равно был бы отбит от мастер-ключа. Самый простой способ генерации: сгенерировать ключ через VinKekFish и/или двойной каскад, затем подать на шифрование в ThreeFish, после чего уже подать на инициализацию в keccak. При этом, так как keccak берёт ключ любой длины, можно генерировать ключи и длинее, чем 512-ть битов (использовать сразу два алгоритма [VinKekFish и двойной каскад], генерирующие минимум по 1024-ре бита, так что keccak будет смешивать эти ключи, дополнительно затрудняя их разделение и сопоставление).



# Таблицы перестановок
// transpose200_8_inv - не используется
transpose200_8
transpose200
transpose128

Реализация алгоритма получения таблиц: VinKekFishBase_etalonK1.GenTransposeTable
Таблицы перестановок расположены в файлах ./tables/transpose-128.txt ./tables/transpose-200.txt ./tables/transpose-200_8.txt

Алгоритм выполнения перестановок в случае таблиц transpose200 и transpose128 состоит в том, чтобы транспонировать матрицу с размером строки 200 и 128 байтов. Под матрицей понимается массив криптографического состояния, который понимается как матрица, сохранённая по строкам подряд в массив.

Тест для проверки верности перестановки:
Пронумеруем байты в исходном массиве как 0, 1, 2, 3 и т.п., то после перестановки transpose200 первые байты должны быть 0, 200, 400, 600, ..., 3000, 1, 201, 401 и т.п.
Исходный массив: 0, 1, 2, 3 и т.п., то после перестановки transpose128 первые байты должны быть 0, 128, 256, 384, ..., 3072, 1, 129, 257 и т.п.

transpose200_8
Таблица выполняется немного по-другому. При достижении индексом максимума (3200), смещение индекса идёт не на 1, а на 8. То есть начинаем новый цикл заполнения с числа +8, вместо числа +1 (перепрыгиваем на 8-мь строк ниже).
При этом, при достижении начальным индексом значения 200 или более, из него вычитается 200, и добавляется 1.

transpose200_8_inv (не используется)
Эта таблица является обратной операцией таблице transpose200_8.
Для размера 3200 - это таблица transpose400_16
Для размера 3200\*K  - это таблица transpose(400\*K)_(16\*K)


Таблицы перестановок выводятся в файл в тесте
\VinKekFish_cryptoDev\permutationsTest\old\VinKekFish\GenTablesTest.cs
Двойное транспонирование не ведёт к той же самой расстановке, что и до двойного транспонирования (см. файл \VinKekFish_cryptoDev\permutationsTest\bin\Debug\results\transpose-200-200.txt). То есть результат после transpose200\*transpose200 будет отличным от исходных данных.

# Количество раундов

Даже при количестве раундов 0 алгоритм должен давать некоторую стойкость.
Однако, в связи с тем, что диффузия может давать какие-то статистические погрешности, количество раундов на впитывание рекомендуется не менее 1. Количество раундов с выводом - не менее 4-х (для K=1).
Однако, для обеспечения большего количества криптографических связей, с ростом K нужно увеличивать и количество раундов.

MIN_ABSORPTION_ROUNDS_D 	Минимальное количество раундов на поглощение (без вывода информации) нестойкое
MIN_ABSORPTION_ROUNDS 		Минимальное количество раундов на поглощение (без вывода информации)
MIN_ROUNDS       		 	Минимальное количество раундов
REDUCED_ROUNDS   			Рекомендуемое сниженное количество раундов
NORMAL_ROUNDS    			Рекомендуемое количество раундов
EXTRA_ROUNDS				Усиленное количество раундов
MAX_ROUNDS                  Максимально рекомендуемое количество раундов (выше почти бессмысленно)


MIN_ABSORPTION_ROUNDS_D     ⌈log(K+1)/log(2)⌉     (1=1 3=2 5=3 7=3 9=4 11=4 13=4 15=4 17=5 19=5)
MIN_ABSORPTION_ROUNDS       ⌈K\*1.337 - 0.328⌉    (2 4 7 10...)
MIN_ROUNDS                  ⌈K\*2.674⌉, но не менее ⌈4\*math.log2(i+1)⌉
                                                  (4 9 14 19...)
REDUCED_ROUNDS              ⌈K\*6.168⌉            (7 19 31 44...)
NORMAL_ROUNDS               ⌈K\*6.168\*1.5⌉       (10 28 47 65...)
EXTRA_ROUNDS                K\*25                 (25 75 125 175...)
MAX_ROUNDS                  ⌈K*25*(2*log(K+1)/log(2)+2)⌉  (50 388 831 1333...)


MIN_ABSORPTION_ROUNDS_D рассчитывается исходя из предполагаемой диффузии. Использование такого количества раундов с выводом из губки может привести к немедленному расшифрованию внутреннего (секретного) состояния губки. Однако, распространение информации внутри губки должно быть уже неплохим, но не криптостойким. Что может повлиять на снижение стойкости, если злоумышленник может осуществить атаку с заданным текстом либо при каких-либо других сложных атаках.
Допустимо при инициализации повторяемыми и известными злоумышленнику значениями, если губка ещё ничем другим не проинициализирована. Вообще, не рекомендуется, дано для сведения.
Для python3
import math
for i in range(1,21,2):
    print(f"{i}: {math.ceil(math.log2(i+1))}")

MIN_ABSORPTION_ROUNDS рассчитывается исходя из того, что каждый блок информации шифруется в одном раунде 2-мя примитивами ThreeFish и двумя примитивами keccak-f. Если считать, что keccak даёт доп. стойкость в 200*(1-4/25)*8=1344 бита, а ThreeFish в 2048*(1-4/25)=1720 битов, то получим стойкость порядка 1344*2+1720*2=6128 битов на раунд, плюс 1344*2=2688 битов на завершающее преобразование.
На раунд нужно получать порядка 8192 битов стойкости, чтобы не снижать номинальную стойкость, учитывая запас (запас с 4Kb до 8Kb стойкости). Следовательно, нужно всего 8192/6128=1.337 раунда на то, чтобы обеспечить номинальную стойкость с запасом. Завершающее преобразование даёт ещё 2688/8192=0.328 раунда.
import math
for i in range(1,21,2):
    print(f"{i}: {math.ceil(i*1.337 - 0.328)}")

MIN_ROUNDS рассчитывается исходя из того, что алгоритмы дают в два раза меньше стойкости (за счёт коллизий и материала, который получает злоумышленник). Завершающее преобразование не учитывается, т.к. оно призвано дополнительно отбивать расчёты от раунда и не считается приносящим стойкость.
При этом предполагаемая неравномерность диффузии должна позволять зашифровать достаточный объём данных (2 петабайта).
import math
def MIN_ROUNDS_2(i):
    return math.ceil(i*2.674)

def DIFF_ROUNDS(i):
    return math.ceil(4*math.log2(i+1))

def MIN_ROUNDS(i):
    m = MIN_ROUNDS_2(i)
    d = DIFF_ROUNDS(i)
    if m < d:
        m = d
    
    return m

for i in range(1,21,2):
    print(f"{i}: {MIN_ROUNDS(i)}")


REDUCED_ROUNDS рассчитывается исходя из того, что остался только один алгоритм, который привносит стойкость, а второй стойкость не привносит. 200 байтов keccak-f - 4/25 блока, 200*(1-4/25)=168 байтов скрытой от злоумышленника информации. Из них половина защищает нас от злоумышленника, остальные идут на коллизии и прочее: 84 байта, то есть 84*8=672 бита на одно применение. Всего 672*2 бита применения за раунд, то есть 1344 бита стойкости за раунд.
8192/1344=6,168 раунда на обеспечение нужной стойкости.
import math
for i in range(1,21,2):
    print(f"{i}: {math.ceil(i*6.168)}")

NORMAL_ROUNDS расчитывается исходя из того, что часть битов может быть дополнительно найдено исходя из различных взаимосвязей в алгоритме. Берётся коэффициент запаса 1.5.
import math
for i in range(1,21,2):
    print(f"{i}: {math.ceil(i*6.168*1.5)}")

EXTRA_ROUNDS (усиленное количество раундов) рассчитывается исходя из того, что в блок VinKekFish помещается 16 блоков keccak и 25 блоков ThreeFish. Если их обрабатывать последовательно, то за соотв. количество раундов мы получим хотя бы одну обработку каждого блока с каждым.
import math
for i in range(1,21,2):
    print(f"{i}: {math.ceil(i*25)}")


MAX_ROUNDS рассчитывается исходя того, что количество блоков при их паросочетаниях будет порядка n^2/2, плюс ещё такое же количество на глубину дерева, чтобы их попарно свести. Таким образом, будет достигнуто полное перемешивание всех со всеми. Так как за раунд выходит 25*K паросочетаний ThreeFish, то получим 25*K, как и в EXTRA_ROUNDS. Представим себе, что каждый блок после такого взаимодействия снова подвергается тому же алгоритму, чтобы дополнительно затруднить криптоанализ тем, что злоумышленнику даже после 25*K раундов криптоанализа доступны только хорошо перемешанные варианты. Для обеспечения ещё большей диффузии так будет 2\*log(k)+2 раз (включая нулевой раз), чтобы все блоки успели обменяться информацией, даже если где-то она потерялась в результате случайности.
import math
for i in range(1,21,2):
    print(f"{i}: {math.ceil(i*25*(2*math.log2(i)+2))}")



# Прикидки стойкости алгоритма

Суммарная длина криптографического состояния 25600 битов.
Скорость - 4096 битов.
Ёмкость, 25600 - 4096 = 21504

Примем за оценку стойкости следующую формулу. Вероятность вскрытия алгоритма равна
P = N^2 / 2^c

Где c - ёмкость, N - количество блоков, доступных для злоумышленника (для вычисления или сверки).

Считая, что P зависит от длины ключа и равна 2^-k (k - длина ключа) можем считать
2^-k = N^2 / 2^c

Длина гаммы в блоках, таким образом, равна
N = 2^((c-k)/2)

Для стойкости 8192 бита
2^(21504-8192)/2=2^(21504-8192)/2=2^6656

Таким образом, длина гаммы (с вероятностью раскрытия не более 2^-k) обеспечена не менее, чем 2^4096 блоков или 2^4105 байтов.


Оценочная неравномерность диффузии (грубая прикидка, возможно, неверная), 2^-20 (одна миллионная) на 4 преобразования с перестановками, то есть на раунд (K=1). (исходя из VinKekFish_cryptoDev\permutationsTest\matrix\r-threefish-transpose128-04.txt)

Исходя из этого можем сделать предположение, что 1 раунд не может быть использован для шифрования более 1 мегабита данных (в том смысле, что выводится более 1 Мбит известного злоумышленнику выхода). 1 раунд на диффузию + рандомизация - это минимальная защита. Значит, далее берём 1 раунд непосредственно на объём данных.
Получаем, что для 2^17\*R байтов можно зашифровать с помощью R+1 раундов.
Таким образом, ограничение на шифрование на одном ключе 4-х раундовым шифром равно 2^17\*3=2^51 байтов, то есть порядка 2,25e15, то есть порядка 2 Петабайт. Разумеется, ключи, желательно, выбирать одноразовыми.


Коллизии. Ожидаемая нагрузка для генерации коллизии равна 2^(c+3)/2 ( https://keccak.team/files/SpongeFunctions.pdf )
2^(21504+3) / 2 = 2^10753,5 ~= 2^10753
С запасом в 4096 битов получаем выше вычисленные 2^6656 (здесь некоторое расхождение с вышеуказанным расчётом, т.к. вычет идёт уже после деления; верный расчёт, вероятнее всего, выше)


## Нагрузка на ключ
Нагрузка на ключ для 4-х раундов - не более 2 Петабайт.
Нагрузка на ключ для 5-ти раундов - не более 2^(17\*4)=2^68=2,95×10²⁰ ≈ 295 Эксабайтов (295 000 Петабайтов)
Для 16-ти раундов - 2^(17\*15)=2^255=5,8e76 байтов.
Для 64-х раундов - 2^(17\*63)=2^1071 байтов
Для 242-х раундов - 2^(17\*241)=2^4097 байтов

На добавление раунда повышение нагрузки примерно в 100 тысяч раз (точнее, в 2^17 раз).
Эта нагрузка на ключ рассчитывается исходя из того, что вся информация шифруется за один раз (то есть нет вероятности пересечения отрезков гаммы - взлом методом перекрытия гамм не учитывается).


Попробуем рассчитать нагрузку на ключ с учётом вероятности перекрытия гамм. Хотя в данном алгоритме гаммы не могут перекрыться, так как перекрытие обеспечивается только коллизией - здесь нет счётчика и гаммы, по сути, каждый раз разные, так как синхропосылка является открытой частью ключа шифрования.


Для расчёта возможного количества сеансов связи n с максимальной длиной отрезка гаммы s (используемого в сессии), и общей длиной гаммы L используем приближённую формулу
n=(    2\*L/s\*ln( 1/(1-p) )    )^0.5
Где L - общая длина гаммы (2^6656 блоков для K=1; вне зависимости от количества раундов; 2^6656\*4096=2^6656\*2^12=2^6668 байтов)
p - ожидаемая вероятность


Например, для максимального отрезка информации, шируемого за раз (за сеанс) s=2^50 (1 Петабайт) и вероятности p=2^-30 (1 на миллиард)
n=(    2\*2^6668/2^50\*ln( 1/(1-p) )    )^0.5 = (    2^6619\*ln( 1/(1-2^-30) )    )^0.5

1/(1-2^-30)=1,00000000093
ln(1,00000000093)=0,00000000093
ln(0.00000000093)/ln(2)=-30
(    2^6619\*2^-30    )^0.5
( 2^6589 )^0.5

Таким образом, можно провести 2^3294 сеансов шифрования по 1 Петабайту в каждом сеансе (при условии обеспечения разности синхропосылок).

Для более простого расчёта формулу можно упростить
n = (  2 * L / s * p  ) ^ 0.5

Если считать в битах, то это (L - s - p)/2 (L, s и p - положительные показатели степени соответствующих чисел)
Например, для приведённого выше примера
(6668 - 50 - 30)/2 = 3294, то есть 2^3294 сеансов шифрования

Для вероятности раскрытия 2^-4096 и длины 2^20 (1 Мегабайт)
(6668 - 20 - 4096)/2 = 1276 => 2^1276 сеансов шифрования

Несмотря на то, что эта величина - приближённая, она довольно большая (в реальности лучше вычесть ещё пару битов, то есть вместо  2^1276 использовать  2^1274; однако практического значения такое вычитание не имеет).


# Тесты для проверок
(не реализованы)
Сжимаемость 7-zip
Частотный тест
	Определение количества нулей и единиц в блоках определённой длинны
	Максимальное отношение нулей и единиц и его распределение от блока к блоку
	Можно смотреть дисбаланс (+1 и -1 вместо 1 и 0; отношение дисбаланса к общему количеству должно уменьшаться при увеличении длины гаммы)
		https://habr.com/ru/company/securitycode/blog/237695/ Частотный побитовый тест
			Sobs = модуль дисбаланса делить на квадратный корень из количества битов (|S|/sqrt(n))
			erfc - функция эрфик для биномиального распределения
				(дополнительная функция ошибок: https://ru.wikipedia.org/wiki/Функция_ошибок )
			P = erfc(Sobs/sqrt(2)) должно быть более, чем 0,01.
		Тест на одинаковые идущие подряд биты (там же)
			Кстати, тест на знакоперемены можно ведь делать и к знакопеременам (правда, там будут худшие результаты)
		Спектральный тест (там же)
	Определение количества значений байтов
		Отношение максимума встреченных байтов к минимуму
		Распределение таких отношений (график)

Длина гаммы в режиме Overwrite с нулевым Tweak


\VinKekFish\main_tests\Задачи и другое\Криптография\Размышления\VinKekFish\РазмыленияОТестах\МинимальноеКоличествоПредставленныхЧисел.txt


# Почему 4096 битов?

Стойкость схем шифрования, желательно, обеспечивать не менее, чем на жизнь человека и его детей. При продолжительности 70-ть лет, это 70+70=140 лет.
Кроме этого, шифр, сам по себе, нужно использовать какое-то время, то есть, допустим, ещё 60 лет. И того - 200 лет стойкости.

Минимальный перевод стойкости в годы: 1 бит за два года.
Более реалистичный, с учётом развития математики и т.п.: 1 бит за 1 год.
Экстремальный: 2 бита за год.

При минимальном переводе, 200 лет стойкости, это 100 битов. При этом, считаем, что в 80-ом году стойким можно было считать шифр в 80-т битов.
Таким образом, базовая минимальная оценка на 2020-ый год: 80 + 40/2 + 100 = 200 битов

"Нормальный" перевод: 80 + 40 + 200 = 320 битов

Экстремальный перевод: 80 + 40*2 + 200*2 = 560 битов

Коэффициенты запаса.
мин  макс (разы)
1,5  2      на уязвимости в шифре.
1,0  2      на уязвимости в схеме.
2    2      на коллизии (считаем, что они обязательно будут).
2    3      на квантовые компьютеры
1,5  2      на уязвимости в самом ключе
1	 2		запас на ПЭМИН (на случай, если противник считывает часть информации, но далеко не всю)

9    96     суммарный коэффициент (произведение коэффициентов)

320*9 = 2880 битов
То есть имеем даже чуть больший запас (на 42%)

320*96 = 30720 битов
VinKekFish позволяет брать себя с удлиняющими коэффициентами, в том числе, K = 3 и K = 5.
Кроме этого, VinKekFish K = 1 может впитать ключ размера 16384 битов за один шаг. Учитывая запас 2 на уязвимость в ключе, это значит, что потребная стойкость 30720/2=15360.

Хотя в схеме VinKekFish максимальная оценка стойкости выше 8192 битов, это дополнительный запас на то, что схема любительская, а также кое-какие ещё запасы на сложность криптоанализа и внутренние коллизии.
4096 битов вывода получаются довольно удобными в плане того, что это не очень много байтов вывода (16% от всех байтов): это затрудняет криптоанализ вывода по сравнению с 8192 битами. Кроме этого, если по ПЭМИН получают 1/2 от имеющейся энтропии, то запас в 2 раза может это компенсировать (а может и нет, ведь энтропию могут получать слишком много раз за непродолжительный промежуток времени).

Для экстремального перевода лет в биты имеем 560*96=53760. VinKekFish удовлетворит это с K = 15 (61440), а с учётом поглощения двойного ключа (то есть запас на некачественный ключ уже выработан) достаточно K = 9 (36864)
