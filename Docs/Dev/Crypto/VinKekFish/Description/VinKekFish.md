Более точное описание реализаций см. в файле .\VinKekFish\GeneralOfDetails.md
Здесь описание примерное

# Незаконченные работы
Тест на длинну гаммы в режиме Overwrite
Проверить в тесте на то, что 1253539379 даёт длительный прирост (без приращения, с умножением).
Проверить по списку типовых ошибок

Сделать статистические тесты (см. в конце)

Сгенерировать таблицы transpose\* и просто задать их. Ну или алгоритм сделать.

Сделать реализации и протестировать их


# Алгоритм VinKekFish

Алгоритм имеет криптографическое состояние и Tweak (настройка для ThreeFish). Для пользователя доступна часть криптографического состояния.
Построен аналогично keccak на основе конструкции Губка (Sponge) и на основе криптографических преобразований keccak и ThreeFish.

Все известные алгоритмы берутся полнораундовыми, так как неполнораундовые с большей вероятностью внесут какие-либо паразитные связи между битами, не соответствующие идеальным перестановкам.

# Полный шаг губки
Перед первым шагом губки (или дуплекса) следует первичная инициализация
Она выполняется для губки (или дуплекса) один раз за всё время её работы. В дальнейшем названия "губка" и "дуплекс" считаются эквивалентными (т.к. работают в данном алгоритме одинаково).

После первичной инициализации следуют шаги шифрования.
Для каждого шага следует:
1. Вычисление нового Tweak для следующего шага
2. Непосредственный ввод данных, изменение Tweak относительно вводимых данных, режима ввода и логического режима шифрования
3. Предварительное преобразование
	3.1. Перестановка для распределения впитанных данных
	3.2. Поблочное шифрование TreeFish
	3.3. Перестановка
4. Основной шаг алгоритма (криптографические раунды)
5. Заключительное преобразование:
	5.1. Заключительная рандомизация, состоящая в поблочном keccak и перестановке. Повторяется некоторое количество раз.
6. Перестановка для объединения данных для вывода (объединена с заключительным преобразованием)
7. Вывод данных

В случае необходимости, для повышения защищённости вывода от ошибок VinKekFish, вывод данных может быть пропущен через губку keccak.
В таком случае, губка может быть инициализирована полным ключом шифрования для VinKekFish, а затем однократным выводом с первого раунда VinKekFish (также, см. ниже).

# Использование губки
Примерное использование губки.

1. Ввод ключа (или открытого вектора инициализации)
2. Ввод открытого вектора инициализации (или ключа)
3. Ввод данных, вывод гаммы
4. Вывод гаммы и/или хеша

## Например, гаммирование с обратной связью по открытому тексту.

1. Ввод ключа, счётчик режимов 1. Инициализация Tweak любым значением. Шаг губки.
2. Ввод ОВИ, счётчик режимов 128. Шаг губки.
3. Вывод блока гаммы (и применение её к открытому тексту).
4. Ввод открытого текста. Счётчик режимов 0. Шаг губки.
5. Вывод блока гаммы
6. И так далее

Реальные схемы шифрования см. в файлах рядом: (пока таких файлов нет)

# Размер криптографического состояния

Размер состояния K*25600,
где K - нечётное натуральное число (1 или более; 1, 3, 5, 7 и т.д. до 19 включительно).
Для K > 11, при перемешивании блоков keccak за один шаг перемешивания невозможно перемешать блоки так, чтобы хотя бы один байт каждого блока был бы представлен в каждом новом блоке. Это может повлечь некоторое снижение стойкости алгоритма при том же количестве раундов (а может и не повлечь).
В связи с этим, рекомендуется использовать алгоритм при K = 1, 3, 5, 7, 9, 11.

Нечётность числа следует из того, что тогда общее количество блоков не делится на два. Для количества блоков 25 следует, что threefish применяется, в частности, к парам (0;12), (12,24), (13,0) [это пары (номер блока, из которого берётся ключ; номер блока, из которого берётся текст для шифрования)].
Если бы блоков было чётное количество, то threefish применялся бы один раз в паре (0;12), а один раз к паре (12; 0). То есть было бы два зависимых между собой криптографических преобразования, которые не были бы зависимы от других блоков. Это упростило бы криптоанализ и уменьшило бы диффузию между блоками.

При нечётном K при преобразовании 0-ого блока ключ берётся из 12-ого блока. Но ключ из 0-ого блока берётся для преобразования 13-ого блока. То есть при многократном преобразовании, блоки будут сами собой перемешивать данные даже без таблиц перестановок и нет ярко выраженной зависимости между двумя блоками. Данные не будут зацикливаться только на одной паре блоков.

Для K > 19 индексы не умещаются в 2-хбайтовых числах, а перемешивание становится всё хуже, поэтому алгоритм использовать не целесообразно и он не разрабатывается для таких значений.

# Размер Tweak
Tweak из ThreeFish используется в служебных целях, но может быть проинициализирован и пользователем.
Как определено в ThreeFish, размер Tweak составляет 16-ть байтов.
В оригинальном ThreeFish третье 8-мибайтовое слово t2 равно t0 ^ t1 (расширение tweak).
В VinKekFish t2 = t0 ^ t1 ^ блок_губки.

Расширение ключа key не производится. Вместо этого берётся лишний блок шифрования.

# Первичная инициализация

Первичная инициализация проходит один раз перед началом использования губки.
Дополнительная инициализация ключами или вектором инициализации происходит в шаге алгоритма (подаваемыми на вход губки или в начальный tweak)


## Tweak

Служебный Tweak инициализируется алгоритмом шифрования (изначально заполняется нулями и затем изменяется при шифровании для каждого раунда, блока и шага губки).
Пользовательский Nonce лучше инициализировать непосредственно в губку, чтобы обеспечить большую радномизацию. То есть Nonce вводить в губку для впитывания, а не в tweak.
В целом, tweak может быть проинициализирован и пользователем.

Положено, что Tweak известен злоумышленнику. Если он не известен, то считается, что злоумышленник может его вычислить.
Так что в Tweak не должно быть конфиденциальных значений, которые не должны быть раскрыты (в целом, это не запрещает инициализировать tweak дополнительным ключевым значением, которое более нигде не используется). Хотя раскрыть хорошо проинициализированный tweak, скорее всего, злоумышленнику будет сложно.


## Криптографическое состояние

### Сложная инициализация

Криптографическое состояние разделяется на строки по 16-ть байтов.
Таблица заполняющих чисел fillTable
0  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61

Далее, для i-ой строки каждого столбца происходит заполнение байта значением (i+1)\*(fillTable[N]), где N есть шаг алгоритма для данного столбца (начиная с нуля).
То есть для нулевой строки, копируется содержание fillTable, для первой строки - содержание fillTable копируется с умножением на два.

Например, для состояния из 32-х байтов состояние будет инициализировано следующими значениями
003 007 010 013 017 019 023 029 031 037 041 043 047 053 059 061 006 014 020 026 034 038 046 058 062 074 082 086 094 106 118 122

Таким образом обеспечивается заполнение всего начального состояния уникальными 16-ти байтовыми значениями для большей начальной рандомизации. Так как алгоритм поблочный, это поможет блокам сильнее отличаться друг от друга на первом шаге.


### Простая инициализация
Пользователь вводит любое значение для инициализации (в том числе и нули), после этого делает шаг губки.
Теперь губка готова к использованию (к вводу ключа и т.п.).


### Инициализация нулями
Вместо указанного выше алгоритма, допускается инициализировать начальное состояние нулями.

В реализациях данного проекта всегда принята инициализация нулями или простая инициализация.


# Вычисление нового Tweak для следующего шага

Если внутреннее состояние губки инициализировано нулями, Tweak не должен быть 0.
При этом, tweak может быть проинициализирован пользователем любым значением. Если он не проинициализирован любым значением, то tweak проинициализирован нулями.

Перед каждым шагом, в том числе перед первым шагом губки осуществляется следующее.
Перед непосредственным вводом данных осуществляется приращение младшего 8-мибайтового слова Tweak (t0) на значение Pi=1253539379 (это простое число, дано в десятичной системе исчисления - в принципе, сюда можно взять любое другое число, лучше - простое). Младшее слово в массиве - первое (младший байт по младшему адресу).
Старшее 8-мибайтовое слово не изменяется (к нему осуществляется приращение при вводе данных). В том числе, бит переноса из младшего слова в старшее не переносится, то есть 8-мибайтовые слова в алгоритме обрабатываются отдельно.

# Непосредственный ввод данных

Ввод данных осуществляется по блокам в 4096*K битов (K*512-ть байтов; то есть длина вводимого блока равна номинальной длине ключа). Блоки вводятся во внешнюю часть криптографического состояния, по одному блоку за раз.
Размер (в байтах) вводимого на текущем шаге блока данных обозначим за r. r имеет размер 2 байта. r вводится в tweak и во внутреннее состояние (описано ниже). Ещё 1 байт (режим ввода) вводится во внутреннее состояние счётчика режимов.
Также в tweak вводятся режимы работы губки (губка или overwrite).

Например, для K = 19 размер ввода (за один шаг губки) ограничен 512*K = 512*19 = 9728 байтов за раз.
Два старших бита размера всегда должны быть пусты, так как туда записываются режимы overwrite (при таком размере это ещё обеспечивается).

## Подробное описание ввода размера и режима

Как вычисляется начальный Tweak описано выше. В том числе, к нему прибавляется число Pi перед каждым шагом губки (в том числе, перед начальным шагом).

* Добавление размера вводимого блока в Tweak
После вычисления нового Tweak (см. выше), к старшему 8-мибайтному слову Tweak добавляется (арифметическим сложением) 2 байта размера вводимого блока (то есть добавляется число r).
* Добавление к старшему байту Tweak
Если ввод осуществляется в режиме overwrite (см. ниже), то к старшему байту старшего 8-мибайтового слова добавляется ещё 1 (то есть добавляется 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову).
В режиме губки к старшему байту ничего не добавляется. Режим padding в режиме overwrite в tweak никак не обозначается.
* Добавление значения счётчика режимов к Tweak
Кроме этого, в любом из режимов, к 3-ему (нумерация, начиная с 1) по старшинству байту старшего 8-мибайтового слова добавляется значение счётчика режимов. Например, если счётчик режимов 3, то добавляется 0x0000_0300_0000_0000 (regime << 40).

* Ввод пользовательских данных
Ввод в криптографическое состояние может осуществляться с операцией побайтового xor (в режиме губки). Первые байты (младшие байты) идут по младшим адресам. Xor осуществляется непосредственно с первыми K*512-тью байтами внутреннего состояния.
Точнее, сначала идёт два байта количества вводимой информации (длина указывается в байтах), потом один байт счётчика режима, а потом ввод (то есть, для K=1 индексы не от 0 до 512 не включая, а от 3 до 515 не включая; для K=3: от 3 до 1539 не включая).
Также ввод может осуществляться простой перезаписью байтов состояния губки вместо xor (режим overwrite) на том же месте. Такой ввод рекомендуется делать в качестве необратимого преобразования для предотвращения вычисления ключа при криптоанализе.
В режиме overwrite байты количества вводимой информации и счётчика режима всё равно вводятся с помощью xor.


padding (заполнение) отсутствует, т.к. в tweak и в первые два байта состояния осуществляется ввод размера вводимого блока. То есть xor осуществляется с вводимыми данными и больше ничего нигде не вводится (кроме 3-х байтов размер и счётчика режима).

В режиме overwrite padding состоит в следующем.
Перезаписывается внешнее криптографическое состояние вводимым массивом байтов.
Если массив байтов недостаточно длинный (менее, чем K*512 байтов), то осуществляется перезапись каждого оставшегося байта (из внешнего состояния) теми же значениями, как при инициализации губки (либо нулями).
Например, если осуществлён ввод числа 01 08 03, то первые 16-ть байтов (точнее, байты [3 .. 18]) при сложной инициализации будут следующими (десятичная система)
001 008 003 013 017 019 023 029 031 037 041 043 047 053 059 061

Однако, это только если выбран сложный вариант инициализации.
Если выбран способ инициализации нулями - то байты просто перезаписываются нулями (допускается перезаписывать нулями при любом режиме инициализации).
001 008 003 000 000 000 000 000 000 000 000 000 000 000 000 000

(В реализациях данного проекта всегда принято заполнение нулями на данном этапе)

Режим overwrite без padding.
В таком случае осуществляется ввод блока информации на длину этого блока. Если блок слишком мал (меньше длины блока внешнего состояния), то никакая перезапись не осуществляется.


Первые два байта криптографического состояния получают xor (всегда именно xor вне зависимости от режима) с числом r (количеством вводимых байтов), и ещё следующий байт получает xor со счётчиком режимов.
Старший бит числа r (количества вводимых байтов) устанавливается в 1, если используется режим overwrite. Если overwrite используется без padding (то есть блок ввода не перезаписывается нулями после конца данных), то второй по старшинству бит также устанавливается.
Счётчик режимов определяется разработчиком схемы шифрования. Он может показывать, что именно происходит. Например, счётчик 1 может показать, что вводится вектор инициализации, счётчик 2 - что вводится ключ, счётчик 0 - что вводятся данные и т.п.
Режим overwrite в данном счётчике никак не обозначается.

Допускается обозначать другие особенности ввода изменением неиспользуемых битов числа r (если K мал) или изменением счётчика режимов (если это не вводит неоднозначности при таком использовании).

Счётчик режимов может работать и в любых иных режимах или игнорироваться (быть нулём, то есть ни на что не влиять, так как a xor 0 = a).

Пример алгоритма назначения счётчика режимов. Счётчик режимов выбирается следующим
1, 2, 3, 4 ... - для блоков ключей (при достижении 127 следующее значение - 0)
128, 129, 130, 131 - для блоков открытых векторов инициализации
255 - для отбоя данных от ключа в режиме overwrite
0 - для остальных вводимых данных.

Ещё один, более простой пример.
Для блоков ключей ввод с режимом 1.
Для блоков открытого вектора инициализации: ввод с режимом 2.
Для отбоя данных от ключа в режиме overwrite (холостой проход с перезаписью нулями): режим 3.
Блоки данных: режим 0.


## Перестановка для распределения впитывания
Затем выполняется перестановка с помощью таблицы transpose128_3200 (см. ниже). То есть перед раундами шифрования идёт однократная перестановка transpose128_3200 (для K=1; для иных K таблица вычисляется аналогичным образом transpose128_* ).
После этого выполняется однократная поблочная операция treefish, и затем снова transpose128.
После этого начинаются раунды шифрования (основной шаг).


Распределение впитывания идёт вне зависимости от того, впитано ли что-либо или нет.
Tweak в этом распределении никак не изменяется (это твик, входящий на этот шаг и использующийся без изменений в первом раунде). То есть он изменяется только перед самим шагом (ввод данных и числа Pi) и внутри поблочного преобразования, но после шага распределения остаётся неизменным.

Распределение позволяет
1. Избежать значительного влияния злоумышленника (своим вводом) на какой-то конкретный блок шифрования, одновременно не выдавая слишком много байтов при выводе
2. Развязать keccak заключительной рандомизации с первым keccak раундов через применение treefish

## Если ввода не было
Если ввод был нулевого размера, то, из вышеописанного алгоритма, следует следующее.

### В режиме губки
Если ввода не было, к tweak добавляется перерасчёт при начале шага +1253539379 (+Pi) к младшему слову.
В состояние и в старшее слово tweak вводится счётчик режима (если он не нулевой). Т.к. длина вводимых байтов равна нулю, то она ничего не изменяет.
Выполняется "Перестановка для распределения впитывания".

### В режиме overwrite
Если ввода не было, к tweak идёт приращение 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову (и +1253539379 к младшему 8-мибайтовому слову).
В tweak и в состояние вводится счётчик режима (так же, как и в режиме губки).
Все 512-ть первых байтов криптографического состояния перезаписываются нулями.
Выполняется "Перестановка для распределения впитывания".


### Ввод данных на следующий шаг не должен зависеть от выхода данных с предыдущего шага

Запрещено осуществлять ввод данных, которые зависят от полученных от губки данных с этого же шага (это не препятствует режиму обратной связи как по открытому тексту, так и по шифротексту; однако режим обратной связи по шифротексту - это режим обратной связи по открытому тексту в режиме overwrite).
Таким образом, данные, вводимые на этом шаге в губку, должны быть известны ранее (с точки зрения логики, а не времени выполнения), чем будут получены выходные данные от губки на этом шаге.
При режиме обратной связи - это всегда режим обратной связи по открытому тексту.

Это важно для того, чтобы злоумышленник не мог воспользоваться выходом дуплекса для того, чтобы его атаковать.
См. стр. 4 "1.3 Our Contribution" "Full-State Keyed Duplex With Built-In Multi-User Support" https://keccak.team/files/FSKD.pdf.


### Ввод ключа

Ввод ключевой информации делается с помощью перезаписи, то есть в режиме overwrite. Это связано с тем, что перезапись информации более безопасна с точки зрения ПЭМИН, чем xor.

Ввод ключа до открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа каждый раз при вводе. Однако, эти данные одни и те же, то есть прибавляют статистику только если оборудование для считывания неточное. В то же время, если оборудование точное - то оно считает ключ полностью либо считает множество данных, являющихся суммой обрабатываемых сигналов в каждый момент времени. За счёт этого, может быть получено довольно много данных.
На следующих шагах (при введении ОВИ) эти данные будут уже преобразовываться с различными данными.
Кроме этого, ввод открытого вектора инициализации возможен в режиме overwrite, что поможет выполнить необратимую операцию и создать неопределённость в отношении ключа для криптоаналитика.


Ввод ключа после открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа, причём каждый раз разные. Однако, в обоих случаях (ввод перед/после), на втором этапе данные будут различны.
В целом, предпочтительнее вводить ОВИ (открытый вектор инициализации) ранее ключа. Так, по крайней мере, не будет ясно видной повторяющейся радиосигнатуры при начале шифрования одним и тем же ключом.


Ввод ключа на первом шаге (до любых преобразований) допускается путём инициализации криптографического состояния этим ключом (то есть простой записи ключа во внутрь состояния или дозаписи с xor), причём размер ключа в таком случае ограничивается лишь внутренним состоянием. Однако, это не рекомендуется (для лучшей рандомизации, лучше вводить ключ по блокам; при этом можно сокращать количество раундов преобразования до 1).
Допускается также одновременный ввод ключа и вектора инициализации тем же путём. Это аналогично инициализации "keyed duplex" в работах по keccak (тоже не рекомендуется).
В таком случае разработчик должен обеспечить недвусмысленное отделение ключа от вектора инициализации, и всего этого от последующих данных. Например, путём фиксирования размера ключа и вектора инициализации. Необходимо также исключить одновременную запись (из разных потоков) в одну линию кеша при инициализации (если инициализацию выполняют несколько потоков), иначе одновременная запись в одну линию кеша повлечёт за собой инвалидацию кешей разных процессорных ядер (незначительное снижение производительности, не более того).

После ввода ключевой информации и ОВИ, рекомендуется всегда делать холостой шаг алгоритма (без ввода данных), чтобы дополнительно отбить ключ. При этом, чтобы затруднить восстановление ключа, холостой шаг может быть сделан в режиме overwrite, то есть с перезаписью части данных нулями (это операция является необратимой и создаёт неопределённость в отношении ключа).

В целом, длина ключа и ОВИ не ограничена, если они вводятся поблочно.


# Вывод данных

## Перестановка для объединения данных для вывода
После выполнения основного шага алгоритма, выполняется заключительное преобразование (заключительная рандомизация), см. ниже в разделе "Основной шаг алгоритма".

## Сам вывод
Если нужен вывод, то берутся первые K*512-ть байтов состояния (младший байт по младшему адресу).
Перестановка выполняется вне зависимости от того, нужен вывод или нет.


# Основной шаг алгоритма

Основной шаг алгоритма состоит из применения 64-х раундов (или другого количества раундов), состоящих из

0. Вычисление tweakVal
(полураунд 0)
1. Поблочное преобразование keccak (точнее keccak-f)
2. Перестановка P1
3. Поблочное преобразование threeFish
4. Перестановка P2
(полураунд 1)
5. Поблочное преобразование keccak
6. Перестановка P3
7. Поблочное преобразование threeFish (с довычисленным tweakVal)
8. Перестановка P4.

После последнего раунда производится заключительное преобразование - заключительная рандомизация. Применяется поблочная функция keccak-f (аналогично пунктам 1 и 5).
То есть идут следующие преобразования (keccak-f + transpose200)\*(keccak-f + transpose200_8)\*(keccak-f + transpose200)\*(keccak-f + transpose200_8)

Допускается использовать (keccak-f + transpose200)\*(keccak-f + transpose200_8) - то есть 2 шага заключительной рандомизации вместо 4-х.
Для K > 11, в связи с худшим перемешиванием, нужно добавить ещё 2 шага (то есть в сумме, 6 шагов, а не 4).


Для P1 используется rnd (случайная перестановка)
Для P2 используется rnd
P3 - transpose200
P4 - transpose128

Для таблиц перестановок rnd рекомендуется первые 8-мь или 4-ре раунда (и, обязательно, первый раунд), использовать P1=transpose200_8 и P2=transpose128. В реализации допускается и отсутствие использования случайных перестановок (то есть использование таблиц transpose200_8+transpose128+transpose200+transpose128 каждый раунд).

Один или оба из P1 или P2 может быть зависим от дополнительного независимого ключа. Предлагается, P1 как зависимый от независимого ключа. Независимый ключ - это ключ, который развязан с основным ключом с помощью алгоритма не меньшей стойкости, чем заданный, либо получен полностью независимо (то есть из количества энтропии не меньшего, чем стойкость основного ключа). Независимость ключа следует из того, что перестановки легче перехватывать по побочным каналам, чем простые ключевые вычисления (таким образом, такой дополнительный ключ может быть считан по ПЭМИН ранее, чем основной ключ).



Довычисление tweakVal происходит следующим образом (tweakVal в начале шага равно tweak).
Работа ведётся с младшим 8-мибайтовым словом tweak (старшее слово не затрагивается, в том числе, бит переноса с младшего слова на старшее не переносится).
Старшее 4-хбайтовое слово tweak складывается с номером раунда, домноженным на 2 - это номер полураунда (tweak не изменяется, запись производится в tweakVal; tweak по прошествии раунда остаётся таким же, каким был до начала раунда).

Для каждого блока 8-мибайтовое младшее слово складывается с номером блока (начиная с нуля). То есть, для нулевого блока используется TweakVal, для первого блока: TweakVal + 1.

Таким образом, на каждый раунд и для каждого блока TweakVal разный.

На второе преобразование threeFish (пункт №7) дополнительно старшее 4-хбайтовое слово tweak приращается на единицу (tweakVal[1] += 0x1_0000_0000;). То есть старшее слово tweak, по сути, складывается с номером полураунда.


## Поблочное преобразование threefish

Пусть N - количество блоков ThreeFish, которые умещаются во внутреннем состоянии.
Тогда j вычисляется как (i + N/2) mod N.
Например, i =  0; N = 25; =>  (0+12) mod 25 = 12.
Например, i = 12; N = 25; => (12+12) mod 25 = 24.
Например, i = 13; N = 25; => (13+12) mod 25 = 0.


Для блока i выполняется преобразование с ключом из блока j и ключом из блока j+1. Причём все блоки берутся из  состояния на момент начала поблочных операций (вывод идёт в отдельный участок памяти). То есть блоки i и j - это блоки, значения которых берутся на момент начала поблочных операций и эти блоки не изменяются.
Расширения ключа в ThreeFish не производятся. Первый (точнее, нулевой) элемент блока j+1 даёт последний ключевой блок key[16]. Блок j даёт остальные ключевые блоки. (j=последний блок => j+1=0)
Расширение tweak производится с изменениями. Берётся tweak[2] = tweak[0] ^ tweak[1] ^ блок_(j-1)[last] (для j-1<0 => j-1=lastBlock).
Где last - это индекс последнего 8-мибайтового слова в блоке (==15). lastBlock - индекс последнего блока в губке (==24\*K).


# Защита после вывода

VinKekFish не проверен криптоаналитиками, поэтому, его стойкость находится под сомнением.
Чтобы уменьшить риски, можно защитить вывод. Однако это не обязательно.

## Работа с VinKekFish
1. Если используется генерация ключевой информации или ОВИ из основного ОВИ и основного ключа.
1.1. Для генерации 512 битных ключей и ОВИ

Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.
Взаимозависимость таких ключей - 512 битов (VinKekFish эту стойкость не увеличивает).

Для усиления защиты, в keccak duplex может быть заранее введён дополнительный ключ. Вместо дополнительного ключа может быть использован следующий алгоритм:
a.1) Ввести в keccak поблочно весь основной ключ (после каждого блока выполнять преобразование keccak), либо ввести специальный дополнительный ключ keccak (последний вариант более стоек)
a.2) Выполнить преобразование VinKekFish (включая ввод основного ключа в VinKekFish)
a.3) Ввести в keccak поблочно выход от преобразования VinKekFish (после каждого блока выполнять преобразование keccak)
a.4) После этого выполнить преобразование VinKekFish и преобразование keccak без ввода данных. Оба преобразования выполняются в режиме overwite и другим счётчиком режимов.
Считать VinKekFish и keccak проинициализированными

После этого выходные данные берутся из keccak без применения VinKekFish (или с применением VinKekFish аналогично пункту 1.3).


Специальный дополнительный ключ допустимо генерировать с помощью keccak из основного ключа и каких-либо дополнительных данных, использующихся только при генерации этого ключа, после чего keccak подвергается перезаписи в режиме overwrite для обеспечения дополнительной необратимости.


1.2. Пункт исключён.

1.3. Для генерации 1024-битный ключей и ОВИ.
ThreeFish
Сгенерировать дополнительный ключ 1024-ре бита (при генерации основного ключа).
1) Ввести основной ключ (либо ещё один дополнительный ключ) в keccak. При этом, каждый вводимый блок зашифровать блочным ThreeFish с дополнительным ключом перед вводом в keccak.
2) Аналогично пункту 1.1.а.2) выполнить над основным ключом преобразование VinKekFish и ввести вывод VinKekFish в keccak. Каждый блок, полученный от VinKekFish, шифровать ThreeFish с дополнительным ключом.
3) Выполнить преобразование аналогично 1.1.а.4).

Выходные данные берутся следующим образом.
Выполняется преобразование VinKekFish. Затем поблочно шифруется ThreeFish. Затем подаётся в keccak. Каждые два входных блока (по 512-ть битов) из keccak можно получить 512-ть битов выхода.


2. Генерация гаммы, стойкостью 512 битов.

Аналогично 1.1. Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.


3. Генерация гаммы, стойкостью 1024 бита. Полагаемся на предположение, что VinKekFish обеспечивает такую стойкость совместно с защитой.

3.1. Исключён.

3.2. Аналогичо 1.3.


4. Универсальный ослабленный вариант. Каждый вывод VinKekFish полностью вводится в keccak duplex по 64-ре байта за ввод. На один полный вывод VinKekFish приходится 64 байта вывода. Эти 64 байта, правда, могут быть независимы друг от друга только на 1024 бита стойкости из-за того, что они вводятся в один и тот же keccak. Но каждый блок будет развязан.
Очень медленный вариант.
4.1. Как более быстрый вариант вместо ввода в keccak полного вывода VinKekFish, может быть осуществлён ввод только 1024 битов информации.


5. Аналогично 1.1. При этом формируется отдельная гамма с помощью одного VinKekFish без защиты keccak, и отдельная гамма с помощью другого VinKekFish с защитой keccak. Ключ для keccak вводится основной, как и в 1.1.
Чтобы два состояния VinKekFish отличались друг от друга необходимо использовать два разных ключа.


## Работа с каскадом keccak

### Каскад keccak
6. Полностью независимое шифрование каскадом keccak


6.1. Каскад keccak
Выполняется инициализация нескольких губок keccak ключами и синхропосылками (как минимум, верхняя губка). При этом губки строятся каскадами.
keccak0
keccak1
keccak2
...

Верхняя губка подаёт (в режиме duplex) свой выход на нижнюю и так далее.
Каждый шаг губка впитывает вывод от более верхней губки и выдаёт вывод на более нижнюю губку.
Вывод самой нижней губки делится пополам. Одна половина (большая, если половины неравные) подаётся на самую вернхнюю губку. Вторая половина (меньшая) является выходом криптографического алгоритма.

При этом, рекомендуется следующее.
1) В каскаде не менее 3-х губок.
2) Пусть k - количество губок в каскаде (желательно, чтобы число было степенью двойки). Тогда вывод нижней губки keccak можно разделить на k равных частей. 1 часть подаётся на выход алгоритма, остальные части подаются на вход самой верхней губки. В то же время, делить можно и на две равные части.
3) Начальная инициализация губок выполняется исходя из условия проведения не менее 1+k\*log2(k) шагов губки без вывода данных (весь нижний вывод даётся на самую верхнюю губку). Шаг алгоритма, при этом, это один шаг всех губок. За k шагов биты, полученные с самой верхней губки поступят в самую верхнюю губку по обратной связи.
4) Инициализация ключом и синхропосылкой может проводиться для самой верхней губки. Ключ (и синхропосылка) вводятся как дополнение к блоку обратной связи (даже на первых k шагах). То есть не по 512-ть битов, а по 512/k битов (если выбрана схема, где в обратную связь уходит 512-512/k битов), либо по 256-битов (если выбрана схема с обратной связью размером в 256-ть битов).



### Двойной каскад keccak-Treefish
6.2. Двойной каскад keccak-Treefish
Создаётся два каскада, аналогичных описанным в пункте 6.1. k - количество уровней каскада.
keccak0L	keccak0R
keccak1L	keccak1R
keccak2L	keccak2R
keccak3L	keccak3R
...

Основной ключ данного каскада состоит из 2\*k\*512 битов (или удвоенного значения).
Дополнительный ключ данного каскада состоит ещё из (k+1)\*1024 битов.

Ключ/синхропосылка может быть подан в каждую губку отдельно. Синхропосылка - через tweak каждого TreeFish. Также синхропосылка может инициализировать отдельно каждую губку. После этого (без каскадирования) в эти губки вносятся части ключей шифрования (как будто губки одиночные).
Далее, на каждом шаге две верхние губки дают данные для одного блока TreeFish. TreeFish выполняет шифрование этих блоков и даёт на выход блок из 1024-х битов. Этот блок разделяется на две нижних губки (на их входы).
В качестве ключевой информации TreeFish принимает ключ 1024 бита. При этом кроме стандартного ключа в 1024 бита в tweak может быть записана либо ключевая информация, либо синхропосылка.

Обратная связь.
С обоих самых нижних губок информация поступает в Treefish аналогично более верхним слоям и, затем, переходит на самые верхние губки (обратная связь).
В случае необходимости ввода информации в каскадную губку, половина ввода вводится через xor с блоком, полученным от обратной связи, в левую (самую верхнюю) губку, а половина - в правую губку.
С самых нижних губок информация поступает на выход. Для этого две губки дают 1024-ре бита информации для шифрования ещё одним ключом ThreeFish (без преобразования для обратной связи). Tweak и key[16] берётся отдельно из блока обратной связи.
После этого выходной блок ThreeFish используется для получения выхода (берётся 1/2 либо 2/k долей информации с этого блока).

В случае, если ключевой информации не хватает для ключей Threefish, они могут быть проинициализированны такой же двойной каскадной губкой, однако ключевые блоки в такой губке могут быть взяты с помощью дополнительного шага этого же уровня каскада.

Для ключа, длиной L битов, целесообразно использовать k=⌈L/1024⌉.


## Рекомендация для дублирующих алгоритмов

С точки зрения оптимальной защиты, можно создать один (или два) keccak duplex и, после первого шага дуплекса VinKekFish, проинициализировать его вводом из VinKekFish (200 байтов ввода, остальные байты выбрасываем либо ещё 200 берём для ОВИ во второй дуплекс). Далее keccak duplex может работать самостоятельно на создание ключей и ОВИ для дублирующего защитного шифрования. А VinKekFish будет использоваться независимо.
Разумеется, здесь есть доверие VinKekFish в плане генерации ключевой информации для дублирующего duplex.

### Использование имитовставок

Так как есть недоверие алгоритмам, то есть и проблема, связанная с тем, что ключ, используемый для шифрования или имитовставки (хеша) может быть вычислен, или может быть определено, что два шифротекста подписаны одним ключом.
Для шифрования проблема решается просто: все гаммы шифров накладываются друг на друга.

Для хешей проблема может решаться по-другому.
1. Большая часть хешей может быть уже зашифрована всеми алгоритмами. То есть должна быть защищена шифрованием.
2. Самые внешние хеши должны использовать одноразовый ключ, восстановление которого не может дать возможности понять, каким именно мастер-ключом подписан данный шифротекст. Ключ должен быть сгенерирован так, чтобы при уязвимости одного алгоритма, ключ всё равно был бы отбит от мастер-ключа. Самый простой способ генерации: сгенерировать ключ через VinKekFish и/или двойной каскад, затем подать на шифрование в ThreeFish, после чего уже подать на инициализацию в keccak. При этом, так как keccak берёт ключ любой длины, можно генерировать ключи и длинее, чем 512-ть битов (использовать сразу два алгоритма [VinKekFish и двойной каскад], генерирующие минимум по 1024-ре бита, так что keccak будет смешивать эти ключи, дополнительно затрудняя их разделение и сопоставление).



# Таблицы перестановок
// transpose200_8_inv - не используется
transpose200_8
transpose200
transpose128

Реализация алгоритма получения таблиц: VinKekFishBase_etalonK1.GenTransposeTable
Таблицы перестановок расположены в файлах ./tables/transpose-128.txt ./tables/transpose-200.txt ./tables/transpose-200_8.txt

Алгоритм выполнения перестановок в случае таблиц transpose200 и transpose128 состоит в том, чтобы транспонировать матрицу с размером строки 200 и 128 байтов. Под матрицей понимается массив криптографического состояния, который понимается как матрица, сохранённая по строкам подряд в массив.

Тест для проверки верности перестановки:
Пронумеруем байты в исходном массиве как 0, 1, 2, 3 и т.п., то после перестановки transpose200 первые байты должны быть 0, 200, 400, 600, ..., 3000, 1, 201, 401 и т.п.
Исходный массив: 0, 1, 2, 3 и т.п., то после перестановки transpose128 первые байты должны быть 0, 128, 256, 384, ..., 3072, 1, 129, 257 и т.п.

transpose200_8
Таблица выполняется немного по-другому. При достижении индексом максимума (3200), смещение индекса идёт не на 1, а на 8. То есть начинаем новый цикл заполнения с числа +8, вместо числа +1 (перепрыгиваем на 8-мь строк ниже).
При этом, при достижении начальным индексом значения 200 или более, из него вычитается 200, и добавляется 1.

transpose200_8_inv (не используется)
Эта таблица является обратной операцией таблице transpose200_8.
Для размера 3200 - это таблица transpose400_16
Для размера 3200\*K  - это таблица transpose(400\*K)_(16\*K)


Таблицы перестановок выводятся в файл в тесте
\VinKekFish_cryptoDev\permutationsTest\old\VinKekFish\GenTablesTest.cs
Двойное транспонирование не ведёт к той же самой расстановке, что и до двойного транспонирования (см. файл \VinKekFish_cryptoDev\permutationsTest\bin\Debug\results\transpose-200-200.txt). То есть результат после transpose200\*transpose200 будет отличным от исходных данных.

# Количество раундов

Даже при количестве раундов 0 алгоритм должен давать хорошую стойкость.
Однако, в связи с тем, что диффузия может давать какие-то статистические погрешности, количество раундов на впитывание рекомендуется не менее 1. Количество раундов с выводом - не менее 4-х (для K=1).

Для упрощения, минимальное количество раундов может увеличиваться на 1 на каждую ступень K (K = 3 => +1, K = 5 => +2, K = 7 => +3, K = 9 => +4, K = 11 => +5). В целом, количество раундов, видимо, может увеличиваться как двоичный логарифм размера криптографического состояния.

Нормальное количество раундов может увеличиваться на 8 на каждую ступень K (K=3 => +8; K=5 => +16).


# Прикидки стойкости алгоритма

Суммарная длина криптографического состояния 25600 битов.
Скорость - 4096 битов.
Ёмкость, 25600 - 4096 = 21504

Примем за оценку стойкости следующую формулу. Вероятность вскрытия алгоритма равна
P = N^2 / 2^c

Где c - ёмкость, N - количество блоков, доступных для злоумышленника (для вычисления или сверки).

Считая, что P зависит от длины ключа и равна 2^-k (k - длина ключа) можем считать
2^-k = N^2 / 2^c

Длина гаммы в блоках, таким образом, равна
N = 2^((c-k)/2)

Для стойкости 8192 бита
2^(21504-8192)/2=2^(21504-8192)/2=2^6656

Таким образом, длина гаммы (с вероятностью раскрытия не более 2^-k) обеспечена не менее, чем 2^4096 блоков или 2^4105 байтов.


Оценочная неравномерность диффузии (грубая прикидка, возможно, неверная), 2^-20 (одна миллионная) на 4 преобразования с перестановками, то есть на раунд. (исходя из VinKekFish_cryptoDev\permutationsTest\matrix\r-threefish-transpose128-04.txt)

Исходя из этого можем сделать предположение, что 1 раунд не может быть использован для шифрования более 1 мегабайта данных (в том смысле, что выводится более 1 Мб известного злоумышленнику выхода). 1 раунд на диффузию + рандомизация - это минимальная защита. Значит, далее берём 1 раунд непосредственно на объём данных.
Получаем, что для 2^20\*R байтов можно зашифровать с помощью R+1 раундов.
Таким образом, ограничение на шифрование на одном ключе 4-х раундовым шифром равно 2^20\*3=2^60 байтов, то есть порядка 1,15e18, то есть порядка 1 эксабайта информации (1150 петабайта). Разумеется, ключи, желательно, выбирать одноразовыми.


Коллизии. Ожидаемая нагрузка для генерации коллизии равна 2^(c+3)/2 ( https://keccak.team/files/SpongeFunctions.pdf )
2^(21504+3) / 2 = 2^10753,5 ~= 2^10753
С запасом в 4096 битов получаем выше вычисленные 2^6656 (здесь некоторое расхождение с вышеуказанным расчётом, т.к. вычет идёт уже после деления)


# Тесты для проверок
Сжимаемость 7-zip
Частотный тест
	Определение количества нулей и единиц в блоках определённой длинны
	Максимальное отношение нулей и единиц и его распределение от блока к блоку
	Можно смотреть дисбаланс (+1 и -1 вместо 1 и 0; отношение дисбаланса к общему количеству должно уменьшаться при увеличении длины гаммы)
		https://habr.com/ru/company/securitycode/blog/237695/ Частотный побитовый тест
			Sobs = модуль дисбаланса делить на квадратный корень из количества битов (|S|/sqrt(n))
			erfc - функция эрфик для биномиального распределения
				(дополнительная функция ошибок: https://ru.wikipedia.org/wiki/Функция_ошибок )
			P = erfc(Sobs/sqrt(2)) должно быть более, чем 0,01.
		Тест на одинаковые идущие подряд биты (там же)
			Кстати, тест на знакоперемены можно ведь делать и к знакопеременам (правда, там будут худшие результаты)
		Спектральный тест (там же)
	Определение количества значений байтов
		Отношение максимума встреченных байтов к минимуму
		Распределение таких отношений (график)

Длина гаммы в режиме Overwrite с нулевым Tweak


\VinKekFish\main_tests\Задачи и другое\Криптография\Размышления\VinKekFish\РазмыленияОТестах\МинимальноеКоличествоПредставленныхЧисел.txt


# Почему 4096 битов?

Стойкость схем шифрования, желательно, обеспечивать не менее, чем на жизнь человека и его детей. При продолжительности 70-ть лет, это 70+70=140 лет.
Кроме этого, шифр, сам по себе, нужно использовать какое-то время, то есть, допустим, ещё 60 лет. И того - 200 лет стойкости.

Минимальный перевод стойкости в годы: 1 бит за два года.
Более реалистичный, с учётом развития математики и т.п.: 1 бит за 1 год.
Экстремальный: 2 бита за год.

При минимальном переводе, 200 лет стойкости, это 100 битов. При этом, считаем, что в 80-ом году стойким можно было считать шифр в 80-т битов.
Таким образом, базовая минимальная оценка на 2020-ый год: 80 + 40/2 + 100 = 200 битов

"Нормальный" перевод: 80 + 40 + 200 = 320 битов

Экстремальный перевод: 80 + 40*2 + 200*2 = 560 битов

Коэффициенты запаса.
мин  макс (разы)
1,5  2      на уязвимости в шифре.
1,0  2      на уязвимости в схеме.
2    2      на коллизии (считаем, что они обязательно будут).
2    3      на квантовые компьютеры
1,5  2      на уязвимости в самом ключе
1	 2		запас на ПЭМИН (на случай, если противник считывает часть информации, но далеко не всю)

9    96     суммарный коэффициент (произведение коэффициентов)

320*9 = 2880 битов
То есть имеем даже чуть больший запас (на 42%)

320*96 = 30720 битов
VinKekFish позволяет брать себя с удлиняющими коэффициентами, в том числе, K = 3 и K = 5.
Кроме этого, VinKekFish K = 1 может впитать ключ размера 16384 битов за один шаг. Учитывая запас 2 на уязвимость в ключе, это значит, что потребная стойкость 30720/2=15360.

Хотя в схеме VinKekFish максимальная оценка стойкости выше 8192 битов, это дополнительный запас на то, что схема любительская, а также кое-какие ещё запасы на сложность криптоанализа и внутренние коллизии.
4096 битов вывода получаются довольно удобными в плане того, что это не очень много байтов вывода (16% от всех байтов): это затрудняет криптоанализ вывода по сравнению с 8192 битами. Кроме этого, если по ПЭМИН получают 1/2 от имеющейся энтропии, то запас в 2 раза может это компенсировать (а может и нет, ведь энтропию могут получать слишком много раз за непродолжительный промежуток времени).

Для экстремального перевода лет в биты имеем 560*96=53760. VinKekFish удовлетворит это с K = 15 (61440), а с учётом поглощения двойного ключа (то есть запас на некачественный ключ уже выработан) достаточно K = 9 (36864)
