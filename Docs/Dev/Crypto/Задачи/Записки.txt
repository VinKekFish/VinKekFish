Fatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication tha>
янв 30 23:35:29 vinny vkf[134478]:    at cryptoprime.BytesBuilder.ToNull(IntPtr, Byte*, UInt64, IntPtr, IntPtr)
янв 30 23:35:29 vinny vkf[134478]:    at maincrypto.keccak.Keccak_abstract.ClearState()
янв 30 23:35:29 vinny vkf[134478]:    at maincrypto.keccak.Keccak_abstract.Clear(Boolean)
янв 30 23:35:29 vinny vkf[134478]:    at maincrypto.keccak.Keccak_base_20200918.Clear(Boolean)
янв 30 23:35:29 vinny vkf[134478]:    at maincrypto.keccak.Keccak_abstract.Dispose(Boolean)
янв 30 23:35:29 vinny vkf[134478]:    at maincrypto.keccak.Keccak_abstract.Dispose()
янв 30 23:35:29 vinny vkf[134478]:    at VinKekFish_EXE.Regime_Service+ContinuouslyGetterRecord.Dispose()
янв 30 23:35:29 vinny vkf[134478]:    at VinKekFish_EXE.Regime_Service+<>c__DisplayClass4_0.<StartContinuouslyGetter>b__0()



70 bytes got from '/sys/class/net/enx00093bf01a40/statistics/rx_bytes'; 0 sended to the main sponges (for the entire time >



янв 31 00:26:40 vinny vkf[153662]: Ошибка при завершении работы программы: обнаружена утечка памяти в mmap: 38 952
янв 31 00:26:40 vinny vkf[153662]: ERROR: Memory successfully cleaned in DeallocateAtBreakage (696 bytes)
янв 31 00:26:40 vinny vkf[153662]: ERROR: Memory successfully cleaned in DeallocateAtBreakage (696 bytes)
янв 31 00:26:40 vinny vkf[153662]: ERROR: Memory successfully cleaned in DeallocateAtBreakage (696 bytes)




Составить общее описание того, что я буду делать, как это будет выглядеть

Fuse (libfuse)
// System.Runtime.InteropServices.UnmanagedFunctionPointer
// https://github.com/libfuse/libfuse/blob/master/example/hello.c#L176
// https://github.com/vzabavnov/dotnetcore.fuse
// https://github.com/vzabavnov/dotnetcore.fuse/blob/master/src/fuse.interop/FuseOpt/Functions.cs
https://github.com/LTRData/FuseDotNet

Xml-документация
	https://docs.microsoft.com/ru-ru/dotnet/csharp/codedoc
	https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/xmldoc/recommended-tags-for-documentation-comments

Какая у меня модель угроз?
Программа работает на незаражённом компьютере
	Но какие меры осложнения выделения ключа надо предпринять?
		Например, компьютер могут заразить прямо сейчас (после окончания работы программы шифрования) или получить к нему физический доступ
Защита от заражения: постараться держать все данные только в оперативной памяти
В идеале, работать только unsafe


Сценарий использования HiJzofkF19z0sGnGmD:
1. Программа открывается автоматически или вручную
2. Получает вручную пароль в защищённом виде
3. Получает имя файла ключа
4. Расшифровывает ключ и хранит его некоторое время
5. Предоставляет другой программе возможность отдавать команды на шифровку файлов этим ключом

Реализация ThreeFish
https://github.com/nitrocaster/SkeinFish
https://www.schneier.com/academic/skein/threefish/

https://docs.microsoft.com/ru-ru/dotnet/api/system.buffers?view=netcore-3.1
Span<T> ReadonlySpan<T>
GCHandle.Alloc
GC.KeepAlive(Object)
	GetTotalMemory(Boolean)

Подумать насчёт использования GC.TryStartNoGCRegion https://docs.microsoft.com/ru-ru/dotnet/api/system.gc.trystartnogcregion?view=netcore-3.1

https://docs.microsoft.com/ru-ru/dotnet/architecture/microservices/secure-net-microservices-web-applications/developer-app-secrets-storage

https://docs.microsoft.com/ru-ru/dotnet/api/system.security.securestring?view=netcore-3.1
	SecureString
		https://github.com/dotnet/platform-compat/blob/master/docs/DE0001.md
		Не рекомендуется к использованию, замена - средства аутентификации Windows :)

https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/stackalloc
	Span<int> numbers = stackalloc int[length]; (выделяет память в стеке)
	int* numbers = stackalloc int[length];
https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/pointer-related-operators
	Это операторы для указателей

https://docs.microsoft.com/ru-ru/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=netcore-3.1
	System.Runtime.InteropServices
		Marshal.AllocHGlobal
			Выделение неуправляемой памяти. Может не заполняться нулями

https://docs.microsoft.com/ru-ru/dotnet/core/diagnostics/debug-memory-leak
	Поиск утечек управляемой памяти
