# Команда генерации первичного ключа шифрования

Команда имеет синонимы:
```
key-main:
key-primary:
key_gen_main:
key-gen-main:
```
Два возможных применения:
1. Генерация случайного файла, пригодного к использованию в качестве ключа.
2. Генерация ключевого форматированного файла, специфичного для VinKekFish.

## Необходимость сервиса vkf
`::warn:onlylinux:sOq1JvFKRxQyw7FQ:`

Данная команда не может работать под операционными системами, где невозможна работа сервиса генерации энтропии "vkf" ("vkf" - это эта же программа, только запущенная в режиме сервиса). При установке программы VinKekFish на Linux с установленной systemd (большинство известных дистрибутивов, кроме Gentoo, уже имеют systemd) сервис "vkf" регистрируется автоматически и запускается при старте системы. То есть, вероятнее всего, у вас уже имеется сервис "vkf", если вы успешно выполнили стандартную полную установку программы VinKekFish.

Если сервис не запущен, то программа, при попытке генерации ключевого файла, выдаст ошибку примерно такого содержания:
```
Не удалось соединиться с сокетом /dev/vkf/random
Cannot assign requested address /dev/vkf/random
```
Если сервис запущен, но находится в состоянии инициализации (это может быть в течении минут 5-7 от завершения старта операционной системы или от перезапуска сервиса, если пользователь делал такой перезапуск), то программа, при попытке выполнить операцию генерации файла, будет ожидать окончания инициализации сервиса vkf. Это может выглядеть как неожиданное зависание программы на этапе первичной инициализации (после этапа 1, вероятнее всего), но это нормально.

Также можно вручную проверить, что сервис vkf запущен.

### Проверка факта работы службы vkf через systemctl
Проверить работу сервиса можно с помощью команды `systemctl status vkf`. Эта команда, в частности, выдаст статус службы `Active: active (running)` (или похожий). Если это не так, то программа не сможет получить рандомизирующие данные от службы "vkf".

Если что-то не работает, получить лог-файл службы можно с помощью команды `journalctl -eu vkf`, но это потребует прав администратора.

### Проверка факта работы службы vkf через чтение /dev/vkf/params
Кроме этого, можно посмотреть статус работы через следующую команду `nc -UN /dev/vkf/params`. Возможно после некоторого времени ожидания, она выдаст вывод, аналогичный данному:
```
    max (bytes)
        2696
    avg (bytes)
        163
    min (bytes)
        31
    EME (bytes)
        0
    removed (bytes)
        0

    max (bytes)
        0
    avg (bytes)
        0
    min (bytes)
        0
    EME (bytes)
        0
    removed (bytes)
        70296
```
Это значит, что служба "vkf" работает.
Если служба "vkf" не работает, то, скорее всего, вы получите примерно такой вывод: `nc: /dev/vkf/params: No such file or directory` (файл не найден).

# 1. Генерация случайного файла, пригодного к использованию в качестве ключа
Включается любой из следующих команд
```
issimple:размер_файла
simple:размер_файла
```
Командой как включается генерация файла, так и назначается его размер.
Команда `issimple:` или `simple:` без значения или со значением, не являющимся положительным целым числом, отключает режим генерации случайного файла.
Внутренне устанавливается флаг isSimpleOutKey. Далее вызывается функция [GenerateSimpleKey](gen/key-main/key.cs).

Имя команды регистронезависимо.

## Задание размера K
Размер K относится к алгоритму VinKekFish и может принимать значения [1; 3; 5; 7; 9; 11; 13; 15; 17; 19] (нечётные значения от 1 до 19 включительно). Значение K характеризует множитель при базовом значении стойкости алгоритма VinKekFish. Номинальная стойкость алгоритма в битах будет равна `K * 4096`, в байтах - `K * 512`. Верхняя оценка стойкости примерно в 2,5 раза выше этого значения.

Любая из команд установит K в значение "1".
```
vinkekfish-k: 1
vkf-k: 1
```

Значение K=11 является значением по умолчанию.


## Задание StrengthInBytes
Значение StrengthInBytes характеризует номинальное значение стойкости алгоритма каскадной губки в байтах. Значение StrengthInBytes * StrengthInBytes / 64 характеризует максимальную оценку стойкости каскадной губки.
```
cascade-k:256
```
Данная команда задаёт стойкость 256 байтов, или, что то же самое, 2048 битов. Это - минимальная стойкость каскадной губки. Размер каскадной губки ничем не ограничен: можно задавать любое из целесообразных значений (ограничение на размер равно 2^31*64-64 = 137 438 953 408 байтов).

Значение StrengthInBytes=11264 является значением по умолчанию.

## Задание внешних рандомизирующих файлов
Программа позволяет использовать внешнюю информацию в виде файлов для рандомизации губок-генераторов.
```
random:path_to_file
rnd:path_to_file
```

При генерации файла или ключа программа будет использовать файл с именем path_to_file в качестве рандомизирующего. Этот файл может быть сгенерирован другой программой. Файлов может быть несколько, в таком случае команда выполняется несколько раз (см. примеры).

Не используйте ключи шифрования в качестве рандомизирующей информации, если только они специально не предназначены для этого и не используются только для этого.

При задании большого рандомизирующего файла программа может работать очень долго. Не задавайте такие файлы.

Не используйте для рандомизации /dev/random и похожие потоки. Почему?
1. Программа зависнет, так как она попытается считать файл до конца, а у потока /dev/random нет конца.
2. Программа и так получит данные из /dev/random (32 байта; размер определяется в файле key.cs, см. строку "GenKeyCommand.InitSponges.br").

В случае, если файла /dev/random нет, программа напишет об этом сообщение. Это не фатальная ошибка, но это ненормально.

В случае, если не будет файла, указанного в rnd:, то
1. Если это произойдёт при указании команды, команда выдаст ошибку. Можно ввести исправленный вариант файла, если включён режим отладки.
2. Если это произойдёт при исполнении программы (файл неожиданно удалён), программа завершит свою работу.

## Примеры генерации случайного файла
```
debug:
key-main:
simple:1024
out:/inRamA/new_key_file
start:
```
Шифрование с K=11 (номинальная стойкость VinKekFish 44 килобита) и StrengthInBytes=11264 выдаст файл, размером 1024 байта (8196 битов).
Файл будет выдан по пути `/inRamA/new_key_file`.
Шифрование может занимать несколько минут времени (так как губкам ещё надо проинициализироваться).

Обратите внимание, файл `/inRamA/new_key_file` не должен существовать. Для генерации больших файлов может потребоваться слишком много времени.

```
debug:
key-main:
vkf-k:1
cascade-k:256
simple:1024
out:/inRamA/new_key_file
start:
```
Файл, размером 1024 байта также будет по пути `/inRamA/new_key_file`. Разница лишь в том, что стойкость шифрования существенно снижена: при генерации этого файла использованы менее стойкие шифры. Стойкость VinKekFish 4 килобита, стойкость каскадной губки 2 килобита.

```
debug:
key-primary:
vkf-k:1
cascade-k:256
simple:1m
out:new_key_file
start:
```
Режим шифрования аналогичный, только теперь файл генерируется в текущей директории (папка, откуда запускается программа). Файл размером 1 мегабайт (точнее, 1 мебибайт == 1024*1024 байтов).
Вместо key-main для разнообразия используем его синоним: key-primary. Это абсолютно ничего не меняет.

```
debug:
key-main:
vkf-k:1
cascade-k:256 2 2 1
simple:1kk
out:/inRamA/new_key_file
start:
```
Генерируется файл, размером 1 мегабайт ("kk" - повторное использование суффикса "k"). Шифрование каскадной губки ослаблено (не делайте так при генерации важных данных!): количество упрочняющих шагов снижено с 9 до 2-х.

```
debug:
key-main:
vkf-k:1
cascade-k:256
simple:1m
rnd:/inRamA/rnd
out:/inRamA/new_key_file
start:
```
Здесь мы вводим в губку рандомизирующий файл /inRamA/rnd. Он должен быть сгенерирован какой-то другой программой и служит для ввода в губку дополнительной энтропии. Не используйте ключи шифрования в качестве рандомизирующей информации, если только они специально не предназначены для этого и не используются только для этого.
При вводе информации из файла на этапе инициализации в отладочном режиме выдаётся сообщение о вводе из данного файла рандомизирующей информации. В данном примере это "3167 bytes from /inRamA/rnd" (файл `rnd` в примере имеет длину 3167 байтов).


```
key-main:
simple:1k
rnd:/inRamA/rnd
out:/inRamA/new_key_file
start:
```
Здесь мы отказываемся от режима отладки (точнее, просто не включаем его, так как по умолчанию он выключен). В таком случае, программа не будет выводить прогресс шифрования, а в случае ошибок завершится с кодом ошибки. Коды ошибок описаны в [ProgramErrorCode.AbandonedByUser](./../ProgrammErrorCode.cs).

В остальном мы делаем то же, что и ранее. Генерируем файл размером 1 килобайт (точнее, кибибайт: 1024 байта), используем для рандомизации файл /inRamA/rnd и выводим сгенерированный файл по пути /inRamA/new_key_file.

```
debug:
key-main:
vkf-k:1
cascade-k:256
simple:1k
rnd:/inRamA/rnd
rnd:/inRamA/rnd1
rnd:/inRamA/rnd2
out:/inRamA/new_key_file
start:
```
Здесь мы вводим три рандомизирующих файла вместо одного. Всё остальное - аналогично примерам выше.
В выдаче нашей программы можно будет найти следующие строки:
```
3167 bytes from /inRamA/rnd
2739 bytes from /inRamA/rnd1
2490 bytes from /inRamA/rnd2
Байтов получено из всех дополнительных случайных файлов: 8396
```
Разумеется, в вашем случае имена и размеры файлов будут другими.

# 2. Генерация ключевого форматированного файла, специфичного для VinKekFish


