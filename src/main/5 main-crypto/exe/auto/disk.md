# disk. Команда шифрованного логического диска (шифрованный том)
Работает только на Linux с установленной libfuse (часто уже установлена).

Данная команда используется для 512-битного шифрования диска с дополнительным усилением от атак грубой силы до 1536 битов стойкости. Это лёгкое шифрование, не дающее особой защиты (по сравнению с каскадной губкой и VinKekFish).
Для шифрования используется нешифрованный ключ - его нужно зашифровать отдельными средствами и после расшифровании положить либо в tmpfs (файловую систему в оперативной памяти, которую пользователь должен примонтировать сам), либо файл ключа должен находится на подмонтированном носителей другой программы шифрования (например, VeraCrypt).
В будущем, в программе появятся функции шифрования ключей, но сейчас возможно сделать только так.

Ключ нужен только для инициализации программы (для монтирования логического диска). После успешного монтирования ключ можно зашифровать другими программами (пока только другими) до следующего монтирования.

# Требования
Работает только на Linux.

В операционной системе должны быть установлены программы libfuse3-3, losetup (часть пакета util-linux), mke2fs (часть пакета e2fsprogs). Вероятнее всего, может понадобиться установка пакета libfuse3-3. Остальное, скорее всего, уже установлено в системе.
Если ОС с менеджером пакетов aptitude (основанные на Debian системы), то проверить, что пакеты установлены, можно следующей командой:
`apt search libfuse3-3 util-linux e2fsprogs | egrep ^i`

Если всё установлено, нормальный вывод примерно таков:
```
i   e2fsprogs                       - утилиты для файловых систем ext2/ext3/ext4
i   libfuse3-3                      - Filesystem in Userspace (library) (3.x ver
i   util-linux                      - различные системные утилиты 
```

Если не установлено, то вывод не будет включать в себя неустановленный пакет.

**Обратите внимание, размещение данного логического диска на SSD-диске или гибридном диске сильно съест его ресурс. Не делайте этого.**

Создание диска (первое монтирование) также требует, чтобы сервис энтропии `vkf` работал (работают пути типа `/dev/vkf/crandom`). Если скрипт `install.sh` завершился успешно, скорее всего, сервис энтропии работает.


# Настойки команды
Для монтирования логического диска, к сожалению, нужны права пользователя root. Следующие команды, подразумевается, будут осуществляться скриптом, запущенным из-под root (командой sudo или ещё как).
Команда на подмонтирование может выглядеть так:

`sudo vkf auto ~/books2.conf`

(либо откройте консоль из-под root командой `sudo -i` и выполняйте команды без лишнего `sudo`).


В этом примере файл конфигурации располагается в домашней директории пользователя и называется books2.conf.

Содержимое файла books2.conf может выглядеть примерно так:
```
debug:
disk:
data:/Arcs/Disks/ya/Arcs/books2/
tmp:/inRamS/books2_tmp
user:/inRamS/books2
key:/inRamA/decrypted.key
size:64G
r:admin:all
start:
```

Что это значит?

##### Вызов команды
Команда debug: переключает нас в режим отладки: мы будем видеть сообщения об успешном монтировании.
Команда disk: показывает программе, что мы хотим смонтировать диск.

##### key
Пусть у пользователя есть папка /inRamA/ в оперативной памяти (туда смонтирована tmpfs) либо на другом шифрованном диске. Ключ шифрования данного диска должен располагаться по пути "/inRamA/decrypted.key". Программа, в настоящий момент времени, требует, чтобы этот ключ был расшифрован, то есть он, сам по себе, ничем не защищён (он может хранится в зашифрованном другими программами виде).
После монтирования зашифрованного диска данный ключ понадобится только при следующем монтировании.
В настоящий момент времени в программу можно подать только один ключевой файл.

###### size
Размер диска определяется параметром size и составит 64 гигабайта. Полностью занятый шифрованный диск займёт чуть больше места (примерно 0,2% больше), однако диск, монтируемый этой программой, является динамическим. Это означает, что он не занимает всё место сразу, поэтому можно выделить большой объём, с запасом.

##### user
Параметр "user" задаёт местоположение папки (далее "папка user"), с которой хочет работать пользователь и куда он будет помещать файлы. Папка может не существовать (и рекомендуется, чтобы не существовала).

Обращу внимание на то, что если папка не пуста, то на время, пока шифрованный раздел будет монтирован, она исчезнет и будет заменена шифрованной папкой (при создании диска эта папка будет пустой). Для шифрования файлов сначала надо создать зашифрованный носитель, и только затем помещать в шифрованную папку файлы для шфирования. Уже существующая папка не будет зашифрована.

Папку можно поместить в любом месте, например, по пути внутри смонтированной tmpfs, это никак не повлияет на её функционирование. Размер папки user может превышать размер носителя информации, который содержит папку-контейнер, так как папка user - виртуальная, она не занимает места.

##### tmp
Папка, указанная в параметре tmp, является служебной: пользователю она не нужна. Её можно смонтировать в поддиректории директории /tmp/ или в любом месте подмонтированной отдельно системы tmpfs (это никак не ограничивает функциональность обоих). В примере, папка монтируется в директории inRamS, которая является папкой файловой системы типа tmpfs.

##### data
Местоположение папки "data" важно. Именно она содержит зашифрованный носитель. Если в папку "user" пользователь переносит файлы, подлежащие шифрованию, то папка "data" содержит эти файлы уже в шифрованном виде (точнее, папка "data" содержит весь логический диск в шифрованном виде).
Эта папка не является виртуальной, она реально существует на диске. Это единственная папка, которая реально существует на диске и она должна быть на реальном носителе информации, где вы хотите хранить зашифрованные данные.
Если необходимо осуществить резервное копирование диска, именно эта папка содержит информацию для резервного копирования. Кроме этой папки так или иначе необходимо сохранить ключ.

##### r
Параметр "r" определяет права доступа к папке user. Точнее, параметр r определяет владельца папки. Если этот параметр не задать, то, так как программа вызывается из-под пользователя root, владелец данной папки также будет root, что повлечёт проблемы с её использованием.
В примере "admin" является пользователем-владельцем, а "all" - группой, которой принадлежит папка.

##### start
Команда, которая говорит, что ввод параметров закончен и можно приступать к монтированию.
После ввода этой строки диск автоматически создастся, отформатируется в формате ext4 и смонтируется в папку "user".

##### mount-o
Если необходимо, то также можно дописать строку, аналогичную
```
mount-o:noexec,nosuid,nodev
```
Команда `mount-o` (команда VinKekFish) дополняет опции монтирования в утилите `mount` (Linux-утилита).
Изначально вызов программы `mount` выглядит примерно так:
```
mount -o relatime,sync /dev/loop14 user
```
Если мы добавим команду:
```
mount-o:noexec,nosuid,nodev
```
то вызов будет выглядеть примерно так
```
mount -o relatime,sync,noexec,nosuid,nodev /dev/loop14 user
```

Указанные параметры "noexec,nosuid,nodev" не позволяют монтировать в директорию `user` устройства и запускать из директории программы. Эти параметры важны для безопасности. Если вы не хотите что-либо запускать с зашифрованного носителя (вы храните на зашифрованном носителе документы, музыку, видео, картинки), то эти опции рекомендуются к использованию.
Подробнее об опциях монтирования можно узнать в руководстве по mount (отдельная программа Linux, входящая в состав Linux по умолчанию) `man mount`.
Опцию можно записать и более строго
```
mount-o:noexec=recursive,nosuid=recursive,nodev=recursive
```
Также пользователь может захотеть использовать опцию `nosymfollow=recursive` (добавляется через запятую).
```
mount-o:noexec=recursive,nosuid=recursive,nodev=recursive,nosymfollow=recursive
```
Опция `ro` монтирует файловую систему как "readonly" (только для чтения), однако сам логический диск монтируется и на запись.
```
mount-o:noexec=recursive,nosuid=recursive,nodev=recursive,nosymfollow=recursive,ro
```

```
Обратите особое внимание на то, что перечень опций разделён запятыми без пробелов. Наличие пробелов вызовет ошибку при монтировании.
```

##### fast-delete
Команда `fast-delete:yes` может чуть повысить скорость операций на диске, но за счёт чуть меньшей безопасности (если вам это не нужно, просто не указывайте эту команду).

###### Пояснения

В обычном режиме, когда данные на шифрованном диске изменяются, программа создаёт новый шифрванный файл-сектор (на физическом диске) с изменёнными данными. Старый файл-сектор перезатирается нулями, а новый файл-сектор перемещается на место старого.
В режиме `fast-delete:yes` старый файл не будет перезатираться нулями. Если злоумышленник имеет доступ к физическому диску, он может попробовать найти старый зашифрованный файл и синхропосылки к нему. Это имеет значение только в том случае, если злоумышленник каким-то образом получил ключ шифрования или диск в расшифрованном варианте, так как тогда он сможет расшифровать старую версию данных.

###### Комментарии
Обратите внимание, что данная перезапись никак не соотносится к безопасному удалению (с помощью перезатирания) файлов на смонтированном носителе. То есть fast-delete управляет перезатиранием служебных зашифрованных блоков.
В то же время, программа не обеспечивает безопасное уничтожение файлов, которые были удалены с монтированного диска. Для этого нужно использовать сторонние программы.

##### alg
Команда alg. Команда alg может быть опущена.
`alg:keccakthreefish` - устаревший алгоритм шифрования, ранее был по умолчанию (не рекомендуется, используйте `alg:keccakthreefish-1.1`).
`alg:keccakthreefish-1.1` - алгоритм шифрования по умолчанию, это keccakthreefish с небольшими изменениями для повышения стойкости.
`alg:keccak` - ослабленный алгоритм шифрования.

Алгоритм шифрования по умолчанию использует губку keccak с обратной связью. При этом, обратная связь подвергается трансформации алгоритмом ThreeFish. В целом, это обеспечивает защиту с минимальной стойкостью 512-ть битов и максимальной стойкостью 1536 битов (512+1024). При этом, хотя номинальная стойкость декларируется 512-ть битов, можно рассчитывать на реальную стойкость именно 1536 битов как минимум для атак грубой силой. Это также затрудняет анализ с помощью квантовых компьютеров, так как квантовому компьютеру придётся проводить анализ не менее чем 1536 битов ключевой информации (если нет никакой упрощающей математической атаки, то квантовый компьютер должен будет подбирать примерно 2048 битов).

`alg:keccak` является ослабленным алгоритмом. В обратной связи губки keccak ничего нет: открытый текст поступает без ThreeFish сразу в губку keccak. Максимальная стойкость такого алгоритма равна 512-ти битам.
За счёт меньшей стойкости шифрования это обеспечивает
* меньшую нагрузку на процессор при шифровании;
* убыстренные в 1,5-2,3 раза операции чтения с диска
* возможно, чуть большую скорость записи (на 10-20%). Скорость записи, к сожалению, больше зависит от большого количества дисковых операций.


# Примеры
```
disk:
data:/Arcs/Disks/ya/Arcs/disk_vkf/
tmp:/tmp/disk_vkf
user:/inRamS/mounts/disk_vkf
key:/media/veracrypt1/keys/disk_vkf.key
size:64G
r:inet:forall
start:
```
Монтирует диск размером 64 гибибайта с ключом, расположенным по пути `/media/veracrypt1/keys/disk_vkf.key`.
Расшифрованный логический том будет доступен по пути `/inRamS/mounts/disk_vkf`, зашифрованные данные находятся по пути `/Arcs/Disks/ya/Arcs/disk_vkf/`. Вспомогательный путь (не нужен пользователю, но будет использован программой): `/tmp/disk_vkf`.
Устанавливает владельцем пользователя `inet` и группу `forall`.

До создания диска должен существовать только ключевой файл `/media/veracrypt1/keys/disk_vkf.key`. Создание осуществляется автоматически при первом запуске программы с этим файлом настроек.

```
disk:
data:/Arcs/Disks/ya/Arcs/disk_vkf/
tmp:/tmp/disk_vkf
user:/inRamS/mounts/disk_vkf
key:/media/veracrypt1/keys/disk_vkf.key
size:1T
r:inet:forall
fast-delete:true
mount-o:noexec=recursive,nosuid=recursive,nodev=recursive
start:
```
Аналогично, но старые зашифрованные блоки не будут перезатёрты нулями. Диск виртуальным размером 1 тебибайт. Установлено, что с диска нельзя запускать программы и интерпретировать с него какие-либо блочные устройства.

```
disk:
data:/Arcs/Disks/ya/Arcs/disk_vkf/
tmp:/tmp/disk_vkf
user:/inRamS/mounts/disk_vkf
key:/media/veracrypt1/keys/disk_vkf.key
size:1M
r:inet:arcs-read
fast-delete:true
alg:keccak
mount-o:nosuid=recursive,nodev=recursive
start:
```
Аналогично примеру выше с путями. Размер 1 мебибайт. Пользователь-владелец - `inet`, группа-владелец `arcs-read`, старые зашифрованные блоки не будут перезатёрты нулями. Включён ослабленный алгоритм шифрования. С диска можно запускать программы, но Linux игнорирует биты set-user-ID и set-group-ID (программы не могут запуститься под root или другого пользователя самостоятельно, также не учитываются Linux capabilities, установленные в файловой системе, подробнее см. `man mount` для nosuid опции), по этим путям не будут интерпретироваться устройства.

###### Замечания
Для обоих алгоритмов шифрования в качестве проверки подлинности используется 512-ти битный хеш.

Если при попытке монтирования вы получаете ошибку
```Hash is incorrect for block: ...```
то, возможно, вы неверно указали ключ шифрования. Либо указан неверный алгоритм шифрования в файле конфигурации. Либо какая-то другая программа испортила данные. Либо случился сбой и эта программа сама испортила данные.

# Опасные операции и оптимизации
## Асинхронные операции
Пусть мы уже смонтировали некоторый диск по пути `/inRamS/mounts/tmp/` (это путь, указанный в строке `user:`).
Тогда можно вызвать из-под root

```mount -o remount,async /inRamS/mounts/tmp/```

(используйте команду `sudo 'команда'` либо `sudo -i` для входа в консоль root)
Эта команда отключает синхронную передачу информации на диск. Теперь при копировании информации на диск будет казаться, что операция выполнилась очень быстро. Однако, никаких операций ещё не выполнено и файловая система "зависнет" и будет в фоновом режиме выполнять эту операцию. Это очень неудобно, но позволяет иногда немного ускорить скорость записи (перед тем, как это делать, хотя бы прикиньте, какая фактическая скорость записи в синхронном режиме, чтобы понять, сколько нужно будет ждать). Пока запись не закончилась (перестала гореть лампочка занятости жёсткого диска на мониторе или команда `iotop` перестала выдавать вверху записывающих команд `vkf auto /inRamA/tmp.conf`), не записывайте на диск ничего другого, чтобы не помешать текущей записи.

`**Обратите внимание, что это иногда приводит к некорректному копированию файлов и скопированные файлы лучше проверять на целостность (хотя бы проверить, что совпадают размеры файлов до байта или суммарные размеры директорий при копировании). Причём, такую проверку лучше делать с перемонтированием диска.**`

В целом, такая операция скорее не рекомендуется.

## Монтирование дисков "только для чтения" (readonly)
Представим себе, что мы монтируем диск следующей командой. Пользовательская директория такого диска обозначена полем `user` и равна `/inRamS/mounts/tmp/`.
```
disk:

data:/tmp/disk_tmp
tmp:/inRamS/tmp/tmp
user:/inRamS/mounts/tmp
key:/inRamA/tmp.key
size:512M
r:inet:forall
fast-delete: true
alg:keccakthreefish-1.1
no-journal: yes
mount-o:noexec=recursive,nosuid=recursive,nodev=recursive,nosymfollow=recursive,ro
start:
```
Опция `ro` монтирует файловую систему только для чтения. Эта опция влияет только на логическую систему (которую видит пользователь), но не на эмулируемое блочное устройство.

Зачем это нужно?

В процессе монтирования для записи всегда записываются служебные данные. Монтируя диск только для чтения мы исключаем запись на него даже служебных данных. Диск остаётся такое же, как был.

Чтобы в процессе работы сделать файловую систему снова доступной для записи, выполните команду
```
mount -o remount,rw /inRamS/mounts/tmp/
```
Разумеется, в команду необходимо подставить нужный путь.

## Форматирование диска без журнала
Форматирование диска без журнала может несколько ускорить запись на диск (иногда, до двух раз), однако это может увеличить вероятность поломки файловой системы при зависаниях компьютера или потере электропитания. Это осуществляется опцией ```no-journal: yes``` при создании (первом монтировании) шифрованного диска.
Пример использования опции приведён чуть выше. Она имеет значение только при первом монтировании и далее диск будет работать так, как был отформатирован при первом монтировании.

## Использование zerofree
Если мы часто записываем информацию на диск, а потом удаляем её, то фактически занимаемое место на диске может быть больше, чем файлы, которые записанны на шифрованный диск. Мы можем сократить размер фактического места, которое занимают данные диска (в директории `data:`, например, выше это директория `/tmp/disk_tmp`).

Снова предположим, что диск монтирован на файловую систему по пути `/inRamS/mounts/tmp/`.
Мы можем ввести команду
```
findmnt | fgrep -i '/inRamS/mounts/tmp'
```
Вывод этой команды будет примерно следующим:
```
/inRamS/mounts/tmp          /dev/loop16            ext4           rw,relatime
```
Мы видим путь, по которому смонтировано устройство, видим путь к логическому устройству (`/dev/loop16`), наименование типа файловой системы (`ext4`), опции монтирования (чтение-запись, одноразовые пометки времени последнего доступа).

Как мы видим выше, устройство монтировано на `/dev/loop16`. Значит, чтобы выполнить команду zerofree нам нужно следующее
```
zerofree -v /dev/loop16
```
(не забываем менять путь в команде на свой; эта команда должна выполняться из-под root, см. `sudo -i`).

Если пакет zerofree не установлен, его можно установить (для основанных на Debian дистрибутивов):
```apt install zerofree```

Если наша файловая система монтирована на чтение-запись, то команда `zerofree -v /dev/loop16` выдаст нам примерно следующее:
```
zerofree: filesystem /dev/loop16 is mounted rw
```
Что значит, что мы должны перемонтировать файловую ситему в режим "только для чтения".
```
mount -o remount,ro /inRamS/mounts/tmp/
```
(не забываем менять путь в команде на свой).
После этого мы уже можем снова исполнять команду ```zerofree -v /dev/loop16``` (разумеется, надо подставить верный путь).

Команда будует выдавать процент завершённых операций. Также мы можем сами смотреть на прогресс другим способом.
Не закрывая программу zerofree, в другой вкладке зайдём в директорию, указанную в опции `data:`, и выполним там команду показа нам количества файлов в директории.
```
cd /tmp/disk_tmp
watch -n 1 'ls -1 | wc -l'
```
Выход из команды `watch` по сочетанию клавиш `ctrl+C`. Мы увидим, как количество файлов постепенно убывает (скорее всего, каждые несколько секунд как минимум на один).

Дождитесь, пока zerofree не будет выполнен (команда `zerofree` не закончит выполнение и не появится приглашение для ввода новых команд).

После выполнения zerofree можно снова смонтировать диск на запись:
```
mount -o remount,rw /inRamS/mounts/tmp/
```


TODO: Написать про то, что создание нового раздела может быть долгим, если программа vkf ещё не инициализировалась
TODO: написать про /etc/sudoers.d
