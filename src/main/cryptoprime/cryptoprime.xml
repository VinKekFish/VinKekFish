<?xml version="1.0"?>
<doc>
    <assembly>
        <name>cryptoprime</name>
    </assembly>
    <members>
        <member name="T:cryptoprime.BytesBuilder">
            <summary>
            BytesBuilder
            Класс позволяет собирать большой блок байтов из более мелких
            Класс непотокобезопасный (при его использовании необходимо синхронизировать доступ к классу вручную)
            </summary>
        </member>
        <member name="F:cryptoprime.BytesBuilder.bytes">
            <summary>Добавленные блоки байтов</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilder.Count">
            <summary>Количество всех сохранённых байтов в этом объекте</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilder.countOfBlocks">
            <summary>Количество всех сохранённых блоков, как они были добавлены в этот объект</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.getBlock(System.Int32)">
            <summary>Получает сохранённых блок с определённым индексом в списке сохранения</summary><param name="number">Индекс в списке</param><returns>Сохранённый блок (не копия, подлинник)</returns>
        </member>
        <member name="F:cryptoprime.BytesBuilder.count">
            <summary>Количество сохранённых байтов</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.add(System.Byte[],System.Int32,System.Boolean)">
            <summary>Добавляет блок в объект</summary><param name="bytesToAdded">Добавляемый блок данных</param>
            <param name="index">Куда добавляется блок. По-умолчанию, в конец (index = -1)</param>
            <param name="MakeCopy">MakeCopy = true говорит о том, что данные блока будут скопированы (создан новый блок и он будет добавлен). По-умолчанию false - блок будет добавлен без копирования. Это значит, что при изменении исходного блока, изменится и выход, даваемый объектом. Если исходный блок будет обнулён, то будет обнулены и выходные байты из этого объекта, соответствующие этому блоку</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.addCopy(System.Byte[],System.Int32)">
            <summary>Копирует данные блока и добавляет его в объект</summary><param name="bytesToAdded">Добавляемый блок</param><param name="index">Индекс для добавления.  index = -1 - добавление в конец</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.addByte(System.Byte,System.Int32)">
            <summary>Добавляет в объект один байт</summary><param name="number">Добавляемое значение</param><param name="index">Индекс добавляемого блока. -1 - в конец</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.addUshort(System.UInt16,System.Int32)">
            <summary>Добавляет в объект двухбайтовое беззнаковое целое. Младший байт по младшему адресу</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.addInt(System.Int32,System.Int32)">
            <summary>Добавляет в объект 4-хбайтовое беззнаковое целое. Младший байт по младшему адресу</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.addULong(System.UInt64,System.Int32)">
            <summary>Добавляет в объект 8-хбайтовое беззнаковое целое. Младший байт по младшему адресу</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.addVariableULong(System.UInt64,System.Int32)">
            <summary>Добавляет в объект специальную кодировку 8-байтового числа, см. функцию VariableULongToBytes</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.add(System.String,System.Int32)">
            <summary>Добавляет в объект строку UTF-8</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilder.Clear(System.Boolean)">
            <summary>Обнуляет объект</summary>
            <param name="fast">fast = <see langword="false"/> - обнуляет все байты сохранённые в массиве</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.getBytes(System.IntPtr,System.Byte[])">
            <summary>Создаёт массив байтов, включающий в себя все сохранённые массивы</summary>
            <param name="resultCount">Размер массива-результата (если нужны все байты resultCount = -1)</param>
            <param name="resultA">Массив, в который будет записан результат. Если resultA = null, то массив создаётся</param>
            <returns></returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.getBytes(System.IntPtr,System.IntPtr,System.Byte[],System.Int32)">
            <summary>Получить resultCount начиная с индекса index</summary>
            <param name="resultCount">Количество байтов для получения. -1 - сформировать массив с байта index до конца байтов источника</param>
            <param name="dIndex">Стартовый индекс байта источника</param>
            <param name="forResult">Массив для хранения результата</param>
            <param name="startIndex">Индекс, с которого заполняется массив forResult (индекс приёмника)</param>
            <returns>Массив результата длиной resultCount</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.RemoveBlockAt(System.Int32,System.Boolean)">
            <summary>Удаляет блок из объекта с позиции position, блок очищается нулями</summary>
            <returns>Возвращает длину удалённого блока</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.getBytesAndRemoveIt(System.Byte[],System.IntPtr)">
            <summary>Создаёт массив байтов, включающий в себя resultCount символов, и удаляет их с очисткой из BytesBuilder</summary>
            <param name="resultA">Массив, в который будет записан результат. Если resultA = null, то массив создаётся</param>
            <param name="resultCount">Размер массива-результата</param>
            <returns>Запрошенный результат (первые resultCount байтов)</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.CloneBytes(System.Byte[],System.IntPtr,System.IntPtr)">
            <summary>Клонирует массив, начиная с элемента start, до элемента с индексом PostEnd (не включая)</summary><param name="B">Массив для копирования</param>
            <param name="start">Начальный элемент для копирования</param>
            <param name="PostEnd">Элемент, расположенный после последнего элемента для копирования. -1 - до конца</param>
            <returns>Новый массив</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.CloneBytes(System.Byte*,System.IntPtr,System.IntPtr)">
            <summary>Клонирует массив, начиная с элемента start, до элемента с индексом PostEnd (не включая)</summary><param name="b">Массив для копирования</param>
            <param name="start">Начальный элемент для копирования</param>
            <param name="PostEnd">Элемент, расположенный после последнего элемента для копирования</param>
            <returns>Новый массив</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.CopyTo(System.Byte[],System.Byte[],System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Копирует массив source в массив target. Если запрошенное количество байт скопировать невозможно, копирует те, что возможно
            </summary>
            <param name="source">Источник копирования</param>
            <param name="target">Приёмник</param>
            <param name="targetIndex">Начальный индекс копирования в приёмник</param>
            <param name="count">Максимальное количество байт для копирования (если столько нет, копирует столько, сколько возможно) (-1 - все доступные)</param>
            <param name="index">Начальный индекс копирования из источника</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.CopyTo(System.IntPtr,System.IntPtr,System.Byte*,System.Byte*,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Копирует массивы по указателям из s в t</summary>
            <param name="sourceLength">Длина массива s</param><param name="targetLength">Длина массива t</param>
            <param name="s">Источник для копирования</param><param name="t">Приёмник для копирования</param>
            <param name="targetIndex">Начальный индекс, с которого будет происходить запись в t</param>
            <param name="count">Количество байтов для записи в t (если столько нет, копирует столько, сколько возможно). Count = -1 - копирует столько, сколько возможно, учитывая размеры источника и приёмника. count не может быть 0</param>
            <param name="index">Начальный индекс копирования из источника s</param>
            <returns>Количество скопированных байтов</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.FillByBytes(System.Byte,System.Byte[],System.IntPtr,System.IntPtr)">
            <summary>Заполняет массив t байтами со значением value</summary><param name="value">Значение для заполнения</param>
            <param name="t">Массив для заполнения</param><param name="index">Индекс первого элемента, с которого будет начато заполнение</param>
            <param name="count">Количество элементов для заполнения. count = -1 - заполнять до конца</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.ToNull(System.Byte[],System.UInt64,System.IntPtr,System.IntPtr)">
            <summary>Обнуляет массив байтов</summary>
            <param name="t">Массив для обнуления</param>
            <param name="val">Значение, которое задаётся массиву (последние 7-мь байтов массиву может задаваться значение младшего байта).
            Для примера, это может быть значение 0x3737_3737__3737_3737 (в x64 значение 0x37 - это invalide OpCode)
            Младший байт по младшему адресу</param>
            <param name="index">Индекс начального элемента для обнуления</param>
            <param name="count">Количество элементов для обнуления, -1 - обнулять до конца</param>
            <returns>Количество обнулённых байтов</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.ToNull(System.IntPtr,System.Byte*,System.UInt64,System.IntPtr,System.IntPtr)">
            <summary>Обнуляет массив байтов по указателю</summary>
            <param name="targetLength">Размер массива для обнуления</param>
            <param name="t">Массив для обнуления</param>
            <param name="val">Значение, которое задаётся массиву (последние 7-мь байтов массиву может задаваться значение младшего байта).
            Для примера, это может быть значение 0x3737_3737__3737_3737 (в x64 значение 0x37 - это invalide OpCode)</param>
            <param name="index">Индекс начального элемента для обнуления</param>
            <param name="count">Количество элементов для обнуления, -1 - обнулять до конца</param>
            <returns>Количество обнулённых байтов</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.UIntToBytes(System.UInt32,System.Byte[]@,System.IntPtr)">
            <summary>Преобразует 4-хбайтовое целое в 4 байта в target по индексу start</summary>
            <param name="data">4-х байтовое беззнаковое целое для преобразования. Младший байт по младшему адресу</param>
            <param name="target">Массив для записи, может быть null</param>
            <param name="start">Начальный индекс для записи числа</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.ULongToBytes(System.UInt64,System.Byte[]@,System.IntPtr)">
            <summary>Преобразует 8-хбайтовое целое в 8 байта в target по индексу start</summary>
            <param name="data">8-х байтовое беззнаковое целое для преобразования. Младший байт по младшему адресу</param>
            <param name="target">Массив для записи, может быть null</param>
            <param name="start">Начальный индекс для записи числа</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.BytesToULong(System.UInt64@,System.Byte[],System.IntPtr)">
            <summary>Получает 8-мибайтовое целое число из массива. Младший байт по младшему индексу</summary>
            <param name="data">Полученное число</param>
            <param name="target">Массив с числом</param>
            <param name="start">Начальный элемент, по которому расположено число</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.BytesToUInt(System.UInt32@,System.Byte[],System.IntPtr)">
            <summary>Получает 4-хбайтовое целое число из массива. Младший байт по младшему индексу</summary>
            <param name="data">Полученное число</param>
            <param name="target">Массив с числом</param>
            <param name="start">Начальный элемент, по которому расположено число</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.BytesToVariableULong(System.UInt64@,System.Byte[],System.IntPtr)">
            <summary>Считывает из массива специальную сжатую кодировку числа. Младший байт по младшему индексу</summary>
            <param name="data">Считанне число</param>
            <param name="target">Массив</param>
            <param name="start">Стартовый индекс, по которому расположено число</param>
            <returns>Количество байтов, которое было считано (размер кодированного числа)</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.VariableULongToBytes(System.UInt64,System.Byte[]@,System.IntPtr)">
            <summary>Записывает в массив специальную сжатую кодировку числа</summary>
            <param name="data">Число для записи</param>
            <param name="target">Массив для записи</param>
            <param name="start">Индекс в массиве для записи туда числа</param>
        </member>
        <member name="M:cryptoprime.BytesBuilder.UnsecureCompare(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>Сравнивает два массива. Тайминг-небезопасный метод</summary>
            <param name="wellHash">Первый массив</param>
            <param name="hash">Второй массив</param>
            <param name="count">Количество элементов для сравнения</param>
            <param name="indexWell">Начальный индекс для сравнения в массиве wellHash</param>
            <returns><see langword="true"/> - если массивы совпадают</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.UnsecureCompare(System.Byte[],System.Byte[],System.IntPtr@)">
            <summary>Сравнивает два массива. Тайминг-небезопасный метод</summary>
            <param name="wellHash">Первый массив для сравнения</param>
            <param name="hash">Второй массив для сравнения</param>
            <param name="i">Индекс эленемта, который не совпадает</param>
            <returns><see langword="true"/> - если массивы совпадают</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilder.ClearString(System.String)">
            <summary>Попытка обнулить char-строку</summary>
            <param name="resultText">Строка для обнуления. Осторожно, resultText.substring(0) может возвращать указатель на ту же строку, т.к. .NET считает строки неизменяемыми</param>
        </member>
        <member name="T:cryptoprime.BytesBuilderForPointers">
            <summary>
            BytesBuilderForPointers
            Класс позволяет собирать большой блок байтов из более мелких
            Класс непотокобезопасный (при его использовании необходимо синхронизировать доступ к классу вручную)
            </summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.bytes">
            <summary>Добавленные блоки байтов</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilderForPointers.Count">
            <summary>Количество всех сохранённых байтов в этом объекте</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilderForPointers.countOfBlocks">
            <summary>Количество всех сохранённых блоков, как они были добавлены в этот объект</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.getBlock(System.Int32)">
            <summary>Получает сохранённых блок с определённым индексом в списке сохранения</summary><param name="number">Индекс в списке</param><returns>Сохранённый блок (не копия, подлинник)</returns>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.count">
            <summary>Количество сохранённых байтов</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.addWithCopy(System.Byte*,System.IntPtr,cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface,System.Int32)">
            <summary>Добавляет копию блока данных в объект</summary><param name="bytesToAdded">Исходный блок данных для добавления</param>
            <param name="len">Длина добавляемого массива</param>
            <param name="allocator">Аллокатор для выделения памяти для копирования</param>
            <param name="index">Индекс, куда добавляется блок. По-умолчанию, в конец (index = -1)</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.addWithoutCopy(System.Byte*@,System.IntPtr,System.Int32)">
            <summary>Добавляет блок данных без копирования в объект</summary><param name="bytesToAdded">Добавляемый блок данных, указатель перезаписывается нулём с целью избежания ошибочного использования. <para>Обратите внимание, что при изменении из-вне блока данных могут измениться данные и внутри объекта</para><para>При удалении блока данных в этом буфере исходные данные будут перезатёрты нулями!</para></param>
            <param name="len">Длина добавляемого массива</param>
            <param name="index">Куда добавляется блок. По-умолчанию, в конец (index = -1)</param>
            <remarks>Обратите внимание, массив bytesToAdded лучше после этого нигде не использовать. Так как после удаления его из буфера, он будет автоматически перезаписан нулями. Необходима доп. проверка на то, что вызывающая функция нигде не использует данный объект</remarks>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.add(cryptoprime.BytesBuilderForPointers.Record,System.Int32)">
            <summary>Добавляет массив в сохранённые значения без копирования. Массив будет автоматически очищен и освобождён после окончания</summary>
            <param name="rec">Добавляемый массив (не копируется, будет уничтожен автоматически при очистке BytesBuilder). Массив нельзя использовать где-то ещё, так как он может быть неожиданно очищен</param>
            <param name="index">Индекс позиции, на которую добавляется массив</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Clear(System.Boolean)">
            <summary>Обнуляет объект</summary>
            <param name="fast">fast = <see langword="false"/> - обнуляет все байты сохранённые в массиве</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.getBytes(System.IntPtr,cryptoprime.BytesBuilderForPointers.Record,cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface)">
            <summary>Создаёт массив байтов, включающий в себя все сохранённые массивы. Ничего не удаляет и не очищает</summary>
            <param name="resultCount">Размер массива-результата (если нужны все байты resultCount = -1)</param>
            <param name="resultA">Массив, в который будет записан результат. Если resultA = null, то массив создаётся</param>
            <param name="allocator">Аллокатор для выделения памяти для копирования</param>
            <returns>Массив байтов результата, длиной resultCount. Если установлен resultA, то возврат совпадает с этим массивом</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.CloneBytes(System.Byte*,System.IntPtr,System.IntPtr,cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface)">
            <summary>Клонирует массив, начиная с элемента start, до элемента с индексом PostEnd (не включая его)</summary><param name="b">Массив для копирования</param>
            <param name="start">Начальный элемент для копирования</param>
            <param name="PostEnd">Элемент, расположенный после последнего элемента для копирования</param>
            <param name="allocator">Аллокатор для выделения памяти для копирования. Не может быть null</param>
            <returns>Новый массив, являющийся копией массива b[start .. PostEnd - 1]</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.CloneBytes(cryptoprime.BytesBuilderForPointers.Record,cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface,System.IntPtr,System.IntPtr)">
            <summary>Клонирует массив, начиная с элемента start, до элемента с индексом PostEnd (не включая его)</summary>
            <param name="rec">Массив для копирования</param>
            <param name="allocator">Аллокатор для выделения памяти для копирования. Может быть null, в таком случае аллокатор получается из rec</param>
            <param name="start">Начальный элемент для копирования</param>
            <param name="PostEnd">Элемент, расположенный после последнего элемента для копирования</param>
            <returns>Новый массив, являющийся копией массива rec[start .. PostEnd - 1]</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.CloneBytes(System.Byte[],cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface,System.IntPtr,System.IntPtr)">
            <summary>Клонирует массив, начиная с элемента start, до элемента с индексом PostEnd (не включая его)</summary>
            <param name="b">Массив для копирования</param>
            <param name="allocator">Аллокатор для выделения памяти для копирования. Не может быть null</param>
            <param name="start">Начальный элемент для копирования</param>
            <param name="PostEnd">Элемент, расположенный после последнего элемента для копирования</param>
            <returns>Новый массив, являющийся копией массива b[start .. PostEnd - 1]</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.RemoveBlockAt(System.Int32,System.Boolean)">
            <summary>Удаляет блок из объекта с позиции position, блок очищается нулями. <para>Эта функция служебная, скорее всего, вам не надо её вызывать</para></summary>
            <returns>Возвращает длину удалённого блока</returns>
            <param name="position">Индекс удаляемого блока</param>
            <param name="doClear">Если true, то удалённый блок очищается нулями и память, выделенная под него, освобождается ( всё это делается вызовом Record.Dispose() )</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.getBytesAndRemoveIt(cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Создаёт массив байтов, включающий в себя result.len символов, и удаляет их с очисткой из BytesBuilder</summary>
            <param name="result">Массив, в который будет записан результат. Уже должен быть выделен. result != <see langword="null"/>. Количество байтов устанавливается длиной массива. <para>Если Result.allocator, то может быть ситуация разыменования <see langword="null"/>, если нет allocator у записей, которые были добавлены в буфер</para></param>
            <returns>Запрошенный результат (первые result.len байтов). Этот возвращаемый результат равен параметру result</returns>
            <remarks>Эта функция может неожиданно обнулить часть внешнего массива, сохранённого без копирования (если он где-то используется в другом месте)</remarks>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.BytesToULong(System.UInt64@,System.Byte*,System.IntPtr,System.IntPtr)">
            <summary>Получает 8-мибайтовое целое число из массива. Младший байт по младшему индексу</summary>
            <param name="data">Полученное число</param>
            <param name="target">Массив с числом</param>
            <param name="start">Начальный элемент, по которому расположено число</param>
            <param name="length">Полная длина массива, до конца должно оставаться не менее 8-ми байтов</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.isArrayEqual_Secure(cryptoprime.BytesBuilderForPointers.Record,cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Безопасно сравнивает два массива</summary>
            <param name="r1">Первый массив</param>
            <param name="r2">Второй массив</param>
            <returns><see langword="true"/>, если массивы совпадают.</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.isArrayEqual_Secure(cryptoprime.BytesBuilderForPointers.Record,cryptoprime.BytesBuilderForPointers.Record,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Безопасно сравнивает два массива</summary>
            <param name="r1">Первый массив</param>
            <param name="r2">Второй массив</param>
            <param name="start1">Начальный индекс для сравнения в первом массиве</param>
            <param name="start2">Начальный индекс для сравнения во втором массиве</param>
            <param name="len1">Длина подмассива для сравнивания</param>
            <param name="len2">Длина подмассива для сравнивания</param>
            <returns><see langword="true"/>, если массивы совпадают.</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Finalize">
            <summary></summary>
        </member>
        <member name="T:cryptoprime.BytesBuilderForPointers.Record">
            <summary>Класс-обёртка для массивов, доступных по указателю</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.Record.array">
            <summary>Массив с данными</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.Record.len">
            <summary>Длина массива с данными</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.Record.handle">
            <summary>Данные для удаления, если этот массив выделен с помощью Fixed_AllocatorForUnsafeMemory</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.Record.ptr">
            <summary>Данные для удаления, если этот массив выделен с помощью AllocHGlobal_AllocatorForUnsafeMemory</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.Record.allocator">
            <summary>Аллокатор, используемый для освобождения памяти в Dispose</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.#ctor">
            <summary>Этот метод вызывать не надо. Используйте AllocatorForUnsafeMemoryInterface.AllocMemory</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.ToString">
            <summary>Выводит строковое представление для отладки в формате "{длина}; элемент элемент элемент"</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.ToString(System.Int32,System.Int32)">
            <summary>Выводит строковое представление для отладки в формате "{длина}; элемент элемент элемент"</summary>
            <param name="maxLen">Максимальное количество элементов массива для вывода в строку</param>
            <param name="maxStrLen">Максимальная длина строки для вывода результата</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Clone">
            <summary>Клонирует запись. Данные внутри записи копируются</summary>
            <returns>Возвращает полностью скопированный массив, независимый от исходного</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Clone(System.IntPtr,System.IntPtr,cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface)">
            <summary>Клонирует запись. Данные внутри записи копируются из диапазона [start .. PostEnd - 1]</summary>
            <param name="start">Начальный элемент для копирования</param>
            <param name="PostEnd">Первый элемент, который не надо копировать</param>
            <param name="allocator">Аллокатор для выделения памяти, может быть <see langword="null"/>, если у this установлен аллокатор</param>
            <returns></returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.NoCopyClone(System.IntPtr)">
            <summary>Копирует запись, но без копированя массива и без возможности его освободить. Массив должен быть освобождён в копируемой записи только после того, как будет закончено использование копии</summary>
            <param name="len">Длина массива либо -1, если длина массива такая же, как копируемой записи</param>
            <returns>Новая запись, указывающая на тот же самый массив</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Clear">
            <summary>Очищает выделенную область памяти (пригодно для последующего использования). Для освобождения памяти используйте Dispose()</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderForPointers.Record.isDisposed">
            <summary>Если true, то объект уже уничтожен</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Dispose">
            <summary>Очищает и освобождает выделенную область памяти</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Free">
            <summary>Вызывает Dispose()</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Dispose(System.Boolean)">
            <summary>Очищает массив и освобождает выделенную под него память</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.Finalize">
            <summary></summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.op_Implicit(cryptoprime.BytesBuilderForPointers.Record)~System.Byte*">
            <summary>Возвращает ссылку на массив</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.op_Implicit(cryptoprime.BytesBuilderForPointers.Record)~System.UInt16*">
            <summary>Возвращает ссылку на массив, преобразованную в тип ushort * </summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.op_Implicit(cryptoprime.BytesBuilderForPointers.Record)~System.UInt64*">
            <summary>Возвращает ссылку на массив, преобразованную в тип unint * </summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Record.op_Addition(cryptoprime.BytesBuilderForPointers.Record,System.IntPtr)">
            <summary>var r = a + Len возвратит запись r, длиной Len, начинающуюся после конца записи a. То есть r.array = a.array + a.len, r.len = Len</summary>
        </member>
        <member name="T:cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface">
            <summary>Интерфейс описывает способ выделения памяти. Реализация: AllocHGlobal_AllocatorForUnsafeMemory</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface.AllocMemory(System.IntPtr)">
            <summary>Выделяет память. Память может быть непроинициализированной</summary>
            <param name="len">Размер выделяемого блока памяти</param>
            <returns>Описатель выделенного участка памяти, включая способ удаления памяти</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface.FreeMemory(cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Освобождает выделенную область памяти. Не очищает память (не перезабивает её нулями). Должен вызываться автоматически в Record</summary>
            <param name="recordToFree">Память к освобождению</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface.FixMemory(System.Byte[])">
            <summary>Производит фиксацию в памяти массива (интерфейс должен реализовывать либо AllocMemory(nint), либо этот метод, либо оба)</summary>
            <param name="array">Исходный массив</param>
            <returns>Зафиксированный массив</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface.FixMemory(System.Object,System.IntPtr)">
            <summary>Производит фиксацию в памяти объекта, длиной length байтов</summary>
            <param name="array">Закрепляемый объект</param>
            <param name="length">Длина объекта в байтах. Длины массивов необходимо домножать на размер элемента массива</param>
            <returns></returns>
        </member>
        <member name="T:cryptoprime.BytesBuilderForPointers.AllocHGlobal_AllocatorForUnsafeMemory">
            <summary>Выделяет память с помощью Marshal.AllocHGlobal</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocHGlobal_AllocatorForUnsafeMemory.AllocMemory(System.IntPtr)">
            <summary>Выделяет память. Память может быть непроинициализированной</summary>
            <param name="len">Длина выделяемого участка памяти</param>
            <returns>Описатель выделенного участка памяти, включая способ удаления памяти</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocHGlobal_AllocatorForUnsafeMemory.FreeMemory(cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Освобождает выделенную область памяти. Не очищает память (не перезабивает её нулями)</summary>
            <param name="recordToFree">Память к освобождению</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocHGlobal_AllocatorForUnsafeMemory.FixMemory(System.Byte[])">
            <summary>Не реализовано</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.AllocHGlobal_AllocatorForUnsafeMemory.FixMemory(System.Object,System.IntPtr)">
            <summary>Не реализовано</summary>
        </member>
        <member name="T:cryptoprime.BytesBuilderForPointers.Fixed_AllocatorForUnsafeMemory">
            <summary>Выделяет память для массива с помощью его фиксации: то есть используется обычный сборщик мусора и GCHandle.Alloc</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Fixed_AllocatorForUnsafeMemory.AllocMemory(System.IntPtr)">
            <summary>Выделяет память с помощью сборщика мусора, а потом фиксирует её. Это работает медленнее раза в 3, чем AllocHGlobal_AllocatorForUnsafeMemory</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Fixed_AllocatorForUnsafeMemory.FreeMemory(cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Освобождает выделенную область памяти. Не очищает память (не перезабивает её нулями)</summary>
            <param name="recordToFree">Память к освобождению</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Fixed_AllocatorForUnsafeMemory.FixMemory(System.Byte[])">
            <summary>Производит фиксацию в памяти массива</summary>
            <param name="array">Исходный массив</param>
            <returns>Зафиксированный массив</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Fixed_AllocatorForUnsafeMemory.FixMemory(System.UInt16[])">
            <summary>Производит фиксацию в памяти массива</summary>
            <param name="array">Исходный массив</param>
            <returns>Зафиксированный массив</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderForPointers.Fixed_AllocatorForUnsafeMemory.FixMemory(System.Object,System.IntPtr)">
            <summary>Производит фиксацию в памяти массива</summary>
            <param name="array">Исходный массив</param>
            <param name="length">Длина массива</param>
            <returns>Зафиксированный массив</returns>
        </member>
        <member name="T:cryptoprime.BytesBuilderStatic">
            <summary>
            BytesBuilderStatic
            BytesBuilderForPointers, реализованный с циклическим буфером
            Класс позволяет собирать большой блок байтов из более мелких
            Класс непотокобезопасный (при его использовании необходимо синхронизировать доступ к классу вручную)
            </summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.size">
            <summary>Размер циклического буфера. Это максимальный размер хранимых данных. Изменяется функцией Resize</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.allocator">
            <summary>Аллокатор для выделения памяти</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.MIN_SIZE">
            <summary>Минимально возможный размер циклического буфера</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.Resize(System.IntPtr)">
            <summary>Изменяет размер циклического буфера без потери данных.<para>Ничего не блокируется, при многопоточных вызовах синхронизация остаётся на пользователе.</para></summary>
            <param name="Size">Новый размер</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.ReadBytesTo(System.Byte*,System.IntPtr)">
            <summary>Прочитать count байтов из циклического буфера в массив target</summary>
            <param name="target">Целевой массив, куда копируются значения</param>
            <param name="count">Количество байтов для копирования. Если меньше нуля, то копируются все байты</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.WriteBytes(System.Byte*,System.IntPtr)">
            <summary>Записывает байты в циклический буфер (добавляет байты в конец)</summary>
            <param name="source">Источник, из которого берутся данные</param>
            <param name="countToWrite">Количество байтов для добавления</param>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.bytes">
            <summary>Адрес циклического буфера == region.array</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.after">
            <summary>Поле, указывающее на первый байт после конца массива</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.region">
            <summary>Обёртка для циклического буфера</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.count">
            <summary>Количество всех сохранённых байтов в этом объекте - сырое поле для корректировки значений</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilderStatic.Count">
            <summary>Количество всех сохранённых байтов в этом объекте</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.Start">
            <summary>End - это индекс следующего добавляемого байта. Для Start = 0 поле End должно быть равно размеру сохранённых данных (End == Count)</summary>
        </member>
        <member name="F:cryptoprime.BytesBuilderStatic.End">
            <summary>End - это индекс следующего добавляемого байта. Для Start = 0 поле End должно быть равно размеру сохранённых данных (End == Count)</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilderStatic.Item(System.IntPtr)">
            <summary>Получает адрес элемента с индексом index</summary>
            <param name="index">Индекс получаемого элемента</param>
            <returns>Адрес элемента массива</returns>
        </member>
        <member name="P:cryptoprime.BytesBuilderStatic.len1">
            <summary>Длина данных, приходящихся на правый (первый) сегмент данных</summary>
        </member>
        <member name="P:cryptoprime.BytesBuilderStatic.len2">
            <summary>Длина данных, приходящихся на левый сегмент данных</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.add(System.Byte*,System.IntPtr)">
            <summary>Добавляет блок в объект</summary><param name="bytesToAdded">Добавляемый блок данных. Содержимое копируется</param><param name="len">Длина добавляемого блока данных</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.add(cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Добавляет массив в сохранённые значения</summary>
            <param name="rec">Добавляемый массив (копируется)</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.Clear(System.Boolean)">
            <summary>Обнуляет объект</summary>
            <param name="fast">fast = <see langword="false"/> - обнуляет все байты сохранённые в массиве</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.getBytes(System.IntPtr,cryptoprime.BytesBuilderForPointers.Record,cryptoprime.BytesBuilderForPointers.AllocatorForUnsafeMemoryInterface)">
            <summary>Создаёт массив байтов, включающий в себя все сохранённые массивы</summary>
            <param name="resultCount">Размер массива-результата (если нужны все байты resultCount = -1)</param>
            <param name="resultA">Массив, в который будет записан результат. Если resultA = null, то массив создаётся</param>
            <param name="allocator">Аллокатор, который позволяет функции выделять память, если resultA == null. Если null, используется this.allocator</param>
            <returns></returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.RemoveBytes(System.IntPtr)">
            <summary>Удаляет байты из начала массива</summary>
            <param name="len">Количество байтов к удалению</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.getBytesAndRemoveIt(cryptoprime.BytesBuilderForPointers.Record)">
            <summary>Создаёт массив байтов, включающий в себя result.len байтов из буфера, и удаляет их с очисткой</summary>
            <param name="result">Массив, в который будет записан результат. Уже должен быть выделен. result != <see langword="null"/>. Длина запрошенных данных устанавливается полем len этой записи</param>
            <returns>Запрошенный результат (первые resultCount байтов), этот возвращаемый результат равен параметру result</returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.getBytesAndRemoveIt(cryptoprime.BytesBuilderForPointers.Record,System.Int32)">
            <summary>Создаёт массив байтов, включающий в себя count байтов из буфера, и удаляет их с очисткой</summary>
            <param name="result">Массив, в который будет записан результат. Уже должен быть выделен. result != <see langword="null"/>.</param>
            <param name="count">Длина запрашиваемых данных</param>
            <returns></returns>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.Dispose(System.Boolean)">
            <summary>Очищает и освобождает всю небезопасно выделенную под объект память</summary>
            <param name="disposing">Всегда true, кроме вызова из деструктора</param>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.Dispose">
            <summary>Очищает и освобождает всю небезопасно выделенную под объект память</summary>
        </member>
        <member name="M:cryptoprime.BytesBuilderStatic.Finalize">
            <summary>Деструктор</summary>
        </member>
        <member name="T:cryptoprime.KeccakPrime">
            <summary>Статический класс, предоставляющий базовые функции и константы keccak. Пример использования см. в vinkekfish.Keccak_PRNG_20201128</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.S_len">
            <summary>Длина строки матрицы в ulong: 5 элементов ulong. См. также c_size</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.S_len2">
            <summary>Размер матрицы в значениях ulong: 5*5=25 элементов ulong. См. также b_size</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.r_512">
            <summary>rate в битах - 576 (размер внешней части криптографического состояния - блок вводимых данных)</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.r_512b">
            <summary>rate в байтах = 72, это размер блока ввода/вывода за один раз</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.r_512s">
            <summary>rate в ulong = 9</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.b_size">
            <summary>25*8=200. Размер основной матрицы S (или "a") и вспомогательной матрицы b в байтах - равен размеру криптографического состояния</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.c_size">
            <summary>5*8=40. Размер вспомогательной матрицы c в байтах - равен размеру строки криптографического состояния. Используется для транспонирования</summary>
        </member>
        <member name="F:cryptoprime.KeccakPrime.RC">
            <summary>Раундовые коэффициенты для шага ι</summary>
        </member>
        <member name="M:cryptoprime.KeccakPrime.roundB(System.UInt64*,System.UInt64*,System.UInt64*)">
            <summary>Реализация раундового преобразования</summary>
            <param name="a">Матрица S (a) - внутреннее состояние. Размер b_size (25*8=200 байтов) либо S_len2 в ulong (25 ulong)</param>
            <param name="c">Вспомогательная матрица размером c_size (5*8=40 байтов)</param>
            <param name="b">Вспомогательная матрица размером b_size (25*8=200 байтов)</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccackf(System.UInt64*,System.UInt64*,System.UInt64*)">
            <summary>Все раунды keccak (24 раунда). a == S, c= C, b = B</summary>
            <param name="a">Зафиксированное внутреннее состояние S: 25 * ulong (константа b_size или S_len2*ulong)</param>
            <param name="c">Массив  C (значения не важны):  5 * ulong (константа c_size=40)</param>
            <param name="b">Матрица B (значения не важны): 25 * ulong (константа b_size=200)</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccack_i(System.UInt64*,System.UInt64*,System.UInt64*,System.Int32,System.Int32)">
            <summary>Неполнораундовый keccack. Параметры аналогичны Keccackf</summary>
            <param name="a">Внутреннее состояние S</param>
            <param name="c">Массив C (состояние не важно)</param>
            <param name="b">Матрица B (состояние не важно)</param>
            <param name="start">Начальный раунд, считается от нуля</param>
            <param name="count">Количество шагов (всего шагов столько, сколько констант в RC)</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccak_Input_512(System.Byte*,System.Byte,System.Byte*,System.Boolean)">
            <summary>Ввод данных в состояние keccak. Предназначен только для версии 512 битов</summary>
            <param name="message">Указатель на очередную порцию данных</param>
            <param name="len">Количество байтов для записи (не более 72-х; константа r_512b)</param>
            <param name="S">Внутреннее состояние S</param>
            <param name="setPaddings">Если <see langword="true"/> - ввести padding в массив (при вычислении хеша делать на последнем блоке <![CDATA[<=]]> 71 байта)</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccak_Input_SHA512(System.Byte*,System.Byte,System.Byte*,System.Boolean)">
            <summary>Ввод данных в состояние keccak для SHA-3 512</summary>
            <param name="message">Указатель на очередную порцию данных</param>
            <param name="len">Количество байтов для записи (не более 72-х; константа r_512b)</param>
            <param name="S">Внутреннее состояние S</param>
            <param name="setPaddings">Если <see langword="true"/> - ввести padding в массив (при вычислении хеша делать на последнем блоке <![CDATA[<=]]> 71 байта)</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccak_InputOverwrite64_512(System.Byte*,System.Byte,System.Byte*,System.Byte)">
            <summary>
            Эта конструкция разработана по мотивам keccak Overwrite, но немного от неё отличается. Здесь нет padding, нет framebit. Длина вводится xor с внутренним состоянием.
            </summary>
            <param name="message">64 байта или менее для ввода с помощью перезаписи</param>
            <param name="len">длина массива message, 64 или менее</param>
            <param name="S">Внутреннее состояние keccak</param>
            <param name="regime">Режим ввода: аналог framebit, но в виде байта</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccak_Input64_512(System.Byte*,System.Byte,System.Byte*,System.Byte)">
            <summary>
            Эта конструкция разработана по мотивам keccak Sponge, но немного от неё отличается. Здесь нет padding, нет framebit. Длина вводится xor с внутренним состоянием.
            </summary>
            <param name="message">64 байта или менее для ввода с помощью перезаписи</param>
            <param name="len">длина массива message, 64 или менее</param>
            <param name="S">Внутреннее состояние keccak</param>
            <param name="regime">Режим ввода: аналог framebit, но в виде байта</param>
        </member>
        <member name="M:cryptoprime.KeccakPrime.Keccak_Output_512(System.Byte*,System.Byte,System.Byte*)">
            <summary>Вывод данных из состояния keccak. Предназначен только для версии 512 битов</summary>
            <param name="output">Указатель на массив, готовый принять данные :[0, 72]</param>
            <param name="len">Количество байтов для записи (не более 72-х; константа r_512b). Обычно используется 64 - это стойкость данного криптографического преобразования</param>
            <param name="S">Внутреннее состояние S :[200]</param>
            <remarks>При вызове надо проверить, что output всегда нужной длины</remarks>
        </member>
        <member name="M:cryptoprime.KeccakPrime.getSHA3_512(System.Byte[],System.Byte[])">
            <summary>Вычисляет хеш SHA-3 с длиной 512 битов</summary>
            <param name="message">Сообщение для хеширования</param>
            <param name="forHash">Массив размером 64 байта (может быть null). После выполнения функции заполнен хешем SHA-3 512, размер 64 байта</param>
            <returns>Хеш SHA-3 512, размер 64 байта (если forHash не был равен нулю, то это ссылка на массив forHash)</returns>
        </member>
        <member name="M:cryptoprime_tests.BytesBuilder_test_parent.getMaxMemory">
            <summary>Работает только под Linux (требуется "/proc/meminfo")</summary>
            <returns></returns>
        </member>
        <member name="T:cryptoprime_tests.ParentAutoSaveTask">
            <summary>Общий класс для задач-наследников AutoSaveTestTask</summary>
        </member>
    </members>
</doc>
